<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Movie Searcher</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            margin-bottom: 20px;
            color: #fff;
            font-weight: 300;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .btn {
            background: #4a9eff;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        .btn:hover {
            background: #5aaeff;
        }
        
        .btn-secondary {
            background: #3a3a3a;
        }
        
        .btn-secondary:hover {
            background: #4a4a4a;
        }
        
        .btn-success {
            background: #4caf50;
        }
        
        .btn-success:hover {
            background: #5cbf60;
        }
        
        .btn:disabled {
            background: #2a2a2a;
            color: #666;
            cursor: not-allowed;
        }
        
        .search-container {
            position: relative;
            margin-bottom: 25px;
        }
        
        #searchInput {
            width: 100%;
            padding: 15px 20px;
            font-size: 18px;
            background: #2a2a2a;
            border: 2px solid #3a3a3a;
            border-radius: 8px;
            color: #fff;
            outline: none;
            transition: border-color 0.2s;
        }
        
        #searchInput:focus {
            border-color: #4a9eff;
        }
        
        #searchInput::placeholder {
            color: #666;
        }
        
        .clear-search-btn {
            display: inline-block;
            margin-top: 6px;
            background: #3a3a3a;
            color: #e0e0e0;
            border: 1px solid #4a4a4a;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .clear-search-btn:hover {
            background: #4a4a4a;
            border-color: #4a9eff;
        }
        
        .clear-search-btn:active {
            background: #2a2a2a;
        }
        
        .filter-options {
            display: flex;
            gap: 0;
            align-items: center;
            margin-top: 0;
            margin-bottom: 25px;
            position: relative;
        }
        
        .btn-group {
            display: inline-flex;
            position: relative;
            vertical-align: middle;
        }
        
        .btn-group-toggle .btn {
            border: 1px solid #4a4a4a !important;
            background: #3a3a3a !important;
            color: #e0e0e0 !important;
            padding: 8px 16px !important;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 0 !important;
            margin: 0;
            outline: none;
        }
        
        .btn-group-toggle .btn:first-child {
            border-top-left-radius: 6px !important;
            border-bottom-left-radius: 6px !important;
        }
        
        .btn-group-toggle .btn:last-child {
            border-top-right-radius: 6px !important;
            border-bottom-right-radius: 6px !important;
        }
        
        .btn-group-toggle .btn:not(:first-child) {
            border-left: none !important;
        }
        
        .btn-group-toggle .btn:hover {
            background: #4a4a4a !important;
            color: #fff !important;
        }
        
        .btn-group-toggle .btn.active {
            background: #4a9eff !important;
            border-color: #4a9eff !important;
            color: #fff !important;
            z-index: 1;
        }
        
        .btn-group-toggle .btn.active:hover {
            background: #5aaeff !important;
            border-color: #5aaeff !important;
        }
        
        .filter-options label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .filter-options input[type="checkbox"],
        .filter-options input[type="radio"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .autocomplete {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        
        .autocomplete-item {
            padding: 12px 20px;
            cursor: pointer;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.1s;
        }
        
        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background: #3a3a3a;
        }
        
        .autocomplete-item:last-child {
            border-bottom: none;
        }
        
        .movie-name {
            font-weight: 500;
            flex: 1;
        }
        
        .movie-meta {
            font-size: 12px;
            color: #999;
            margin-left: 15px;
        }
        
        .results {
            margin-top: 20px;
        }
        
        .result-item {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            padding: 15px 20px;
            margin-bottom: 10px;
            transition: background 0.2s;
        }
        
        .result-item:hover {
            background: #333;
        }
        
        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }
        
        .result-info {
            flex: 1;
        }
        
        .result-name {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 5px;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .watched-badge {
            background: #4caf50;
            color: #fff;
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 12px;
        }
        
        .result-path {
            font-size: 12px;
            color: #999;
            margin-bottom: 5px;
            word-break: break-all;
        }
        
        .result-meta {
            font-size: 12px;
            color: #777;
        }
        
        .external-links {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .external-link {
            color: #4a9eff;
            text-decoration: none;
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            transition: all 0.2s;
        }
        
        .external-link:hover {
            background: #2a2a2a;
            border-color: #4a9eff;
            color: #5aaeff;
        }
        
        .result-actions {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .launch-btn {
            background: #4a9eff;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        .launch-btn:hover {
            background: #5aaeff;
        }
        
        .watched-btn {
            background: #3a3a3a;
            color: #fff;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        .watched-btn:hover {
            background: #4a4a4a;
        }
        
        .watched-btn.watched {
            background: #4caf50;
        }
        
        .watched-btn.watched:hover {
            background: #5cbf60;
        }
        
        .subtitle-select {
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #3a3a3a;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .subtitle-select:focus {
            outline: none;
            border-color: #4a9eff;
        }
        
        .stats {
            margin-top: 30px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 8px;
            font-size: 14px;
            color: #999;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }
        
        .watched-section {
            margin-top: 30px;
            display: none;
        }
        
        .watched-section.active {
            display: block;
        }
        
        .section-title {
            font-size: 20px;
            font-weight: 500;
            margin-bottom: 15px;
            color: #fff;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #999;
        }
        
        .status-message {
            padding: 10px 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 14px;
        }
        
        .status-message.success {
            background: #1e4620;
            color: #4caf50;
            border: 1px solid #4caf50;
        }
        
        .status-message.error {
            background: #4a1e1e;
            color: #f44336;
            border: 1px solid #f44336;
        }
        
        .status-message.info {
            background: #1e3a4a;
            color: #4a9eff;
            border: 1px solid #4a9eff;
        }
        
        .folder-info {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: #2a2a2a;
            border-radius: 6px;
            font-size: 13px;
            color: #999;
            flex: 1;
            min-width: 200px;
        }
        
        .folder-path {
            color: #e0e0e0;
            word-break: break-all;
        }
        
        .folder-input {
            display: none;
        }
        
        .folder-dialog {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            border: 2px solid #3a3a3a;
            border-radius: 8px;
            padding: 20px;
            z-index: 2000;
            min-width: 400px;
            max-width: 600px;
        }
        
        .folder-dialog.active {
            display: block;
        }
        
        .folder-dialog h3 {
            margin-bottom: 15px;
            color: #fff;
        }
        
        .folder-dialog input[type="text"] {
            width: 100%;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            margin-bottom: 15px;
        }
        
        .folder-dialog .dialog-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .progress-container {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 8px;
            border: 1px solid #3a3a3a;
        }
        
        .progress-container.active {
            display: block;
        }
        
        .progress-bar-container {
            width: 100%;
            height: 24px;
            background: #1a1a1a;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 10px;
            border: 1px solid #3a3a3a;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4a9eff, #5aaeff);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 12px;
            font-weight: 500;
        }
        
        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: #999;
            margin-bottom: 5px;
        }
        
        .progress-file {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            word-break: break-all;
        }
        
        .scan-log-window {
            margin-top: 15px;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
            padding: 10px;
        }
        
        .scan-log-window::-webkit-scrollbar {
            width: 8px;
        }
        
        .scan-log-window::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        .scan-log-window::-webkit-scrollbar-thumb {
            background: #4a4a4a;
            border-radius: 4px;
        }
        
        .scan-log-window::-webkit-scrollbar-thumb:hover {
            background: #5a5a5a;
        }
        
        .log-entry {
            margin-bottom: 4px;
            padding: 2px 0;
            word-wrap: break-word;
        }
        
        .log-entry .log-timestamp {
            color: #666;
            margin-right: 8px;
        }
        
        .log-entry.info {
            color: #e0e0e0;
        }
        
        .log-entry.success {
            color: #4caf50;
        }
        
        .log-entry.warning {
            color: #ff9800;
        }
        
        .log-entry.error {
            color: #f44336;
        }
        
        .log-entry .log-level {
            display: inline-block;
            width: 60px;
            font-weight: 500;
            margin-right: 8px;
        }
        
        .media-gallery {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            max-width: 100%;
        }
        
        .media-item {
            position: relative;
            cursor: pointer;
            border-radius: 6px;
            overflow: hidden;
            border: 2px solid #3a3a3a;
            transition: border-color 0.2s, transform 0.2s;
            background: #1a1a1a;
        }
        
        .media-item:hover {
            border-color: #4a9eff;
            transform: scale(1.05);
            z-index: 10;
        }
        
        .media-item img {
            display: block;
            width: 200px;
            height: 112px;
            object-fit: cover;
            background: #1a1a1a;
        }
        
        .media-item.large {
            width: 300px;
            height: 169px;
        }
        
        .media-item.large img {
            width: 300px;
            height: 169px;
        }
        
        .media-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            color: #fff;
            padding: 5px 8px;
            font-size: 11px;
            text-align: center;
        }
        
        .media-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 3000;
            cursor: pointer;
            align-items: center;
            justify-content: center;
        }
        
        .media-overlay.active {
            display: flex;
        }
        
        .media-overlay img {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
        }
        
        .media-overlay-close {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #fff;
            font-size: 30px;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.5);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .media-overlay-close:hover {
            background: rgba(0, 0, 0, 0.8);
        }
        
        .star-rating {
            display: inline-flex;
            gap: 1px;
            align-items: center;
            cursor: pointer;
            user-select: none;
            margin-right: 8px;
        }
        
        .star {
            font-size: 18px;
            color: #666;
            transition: color 0.2s, transform 0.1s;
            position: relative;
            width: 18px;
            height: 18px;
            display: inline-block;
        }
        
        .star:hover {
            transform: scale(1.2);
        }
        
        .star.active {
            color: #ffd700;
        }
        
        .star.half {
            position: relative;
        }
        
        .star.half::before {
            content: '★';
            position: absolute;
            left: 0;
            top: 0;
            width: 50%;
            overflow: hidden;
            color: #ffd700;
        }
        
        .star-rating:hover .star {
            color: #ffd700;
        }
        
        .star-rating .star.active ~ .star {
            color: #666;
        }
        
        .star-rating .star.half ~ .star {
            color: #666;
        }
        
        .explore-section {
            margin-top: 30px;
            display: none;
        }
        
        .explore-section.active {
            display: block;
        }
        
        .explore-filters {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .explore-filters label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .explore-filters input[type="radio"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .letter-nav {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 8px;
            border: 1px solid #3a3a3a;
        }
        
        .letter-btn {
            background: #3a3a3a;
            color: #e0e0e0;
            border: 1px solid #4a4a4a;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            min-width: 40px;
            text-align: center;
        }
        
        .letter-btn:hover {
            background: #4a4a4a;
            border-color: #4a9eff;
        }
        
        .letter-btn.active {
            background: #4a9eff;
            border-color: #4a9eff;
            color: #fff;
        }
        
        .letter-btn:disabled {
            background: #1a1a1a;
            color: #555;
            border-color: #2a2a2a;
            cursor: not-allowed;
        }
        
        .movie-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .movie-card {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            overflow: hidden;
            transition: transform 0.2s, border-color 0.2s;
            cursor: pointer;
            max-width: 320px;
            width: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .movie-card:hover {
            transform: translateY(-4px);
            border-color: #4a9eff;
        }
        
        .movie-card-image {
            width: 100%;
            aspect-ratio: 16 / 9;
            min-height: 180px;
            max-height: 280px;
            background: #1a1a1a;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 14px;
            position: relative;
            overflow: hidden;
        }
        
        .movie-card-image img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            object-position: center;
        }
        
        .movie-card-body {
            padding: 15px;
        }
        
        .movie-card-title {
            font-size: 14px;
            font-weight: 500;
            color: #fff;
            margin-bottom: 10px;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        .movie-card-actions {
            display: flex;
            gap: 8px;
        }
        
        .movie-card-launch {
            flex: 1;
            background: #4a9eff;
            color: #fff;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }
        
        .movie-card-launch:hover {
            background: #5aaeff;
        }
        
        .pagination {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        .pagination-btn {
            background: #3a3a3a;
            color: #e0e0e0;
            border: 1px solid #4a4a4a;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .pagination-btn:hover:not(:disabled) {
            background: #4a4a4a;
            border-color: #4a9eff;
        }
        
        .pagination-btn:disabled {
            background: #1a1a1a;
            color: #555;
            border-color: #2a2a2a;
            cursor: not-allowed;
        }
        
        .pagination-btn.active {
            background: #4a9eff;
            border-color: #4a9eff;
            color: #fff;
        }
        
        .pagination-info {
            color: #999;
            font-size: 14px;
            margin: 0 10px;
        }
        
        .page {
            display: none;
        }
        
        .page.active {
            display: block;
        }
        
        .nav-link {
            background: #3a3a3a;
            color: #e0e0e0;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
            text-decoration: none;
            display: inline-block;
        }
        
        .nav-link:hover {
            background: #4a4a4a;
        }
        
        .nav-link.active {
            background: #4a9eff;
            color: #fff;
        }
        
        .movie-card-meta {
            font-size: 12px;
            color: #999;
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .launch-status-checkbox {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid #4a9eff;
            background: transparent;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .launch-status-checkbox.launched {
            background: #4a9eff;
            border-color: #4a9eff;
        }
        
        .launch-status-checkbox.launched::after {
            content: '✓';
            color: #fff;
            font-size: 12px;
            font-weight: bold;
        }
        
        .movie-card-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        .movie-card-btn {
            background: transparent;
            color: #e0e0e0;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
        }
        
        .movie-card-btn:hover {
            background: #3a3a3a;
        }
        
        .movie-card-btn .watched-checkbox {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            background: #4caf50;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .movie-card-btn .watched-checkbox::after {
            content: '✓';
            color: #fff;
            font-size: 9px;
            font-weight: bold;
        }
        
        .movie-card-btn.rating {
            background: #ffd700;
            color: #000;
        }
        
        .movie-card-buttons .star-rating {
            flex: 1;
            margin-right: 0;
            justify-content: center;
            padding: 4px 0;
        }
        
        .movie-card-buttons .star-rating .star {
            font-size: 14px;
            width: 14px;
            height: 14px;
        }
        
        .movie-details-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .movie-details-header {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .movie-details-poster {
            flex-shrink: 0;
            width: 300px;
            height: 450px;
            background: #1a1a1a;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .movie-details-poster img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .movie-details-info {
            flex: 1;
        }
        
        .movie-details-title {
            font-size: 32px;
            font-weight: 500;
            color: #fff;
            margin-bottom: 10px;
        }
        
        .movie-details-meta {
            font-size: 14px;
            color: #999;
            margin-bottom: 20px;
        }
        
        .movie-details-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .back-button {
            background: #3a3a3a;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
            margin-bottom: 20px;
        }
        
        .back-button:hover {
            background: #4a4a4a;
        }
        
        .setup-section {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .setup-section h3 {
            color: #fff;
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 15px;
        }
        
        .setup-section p {
            color: #999;
            font-size: 14px;
            margin-bottom: 15px;
            line-height: 1.5;
        }
        
        .setup-option {
            margin-bottom: 20px;
        }
        
        .setup-option label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-size: 14px;
            color: #e0e0e0;
        }
        
        .setup-option input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .setup-option-description {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            margin-left: 28px;
        }
        
        .currently-playing {
            font-size: 13px;
            color: #999;
            font-style: italic;
        }
        
        .currently-playing.has-movie {
            font-style: normal;
            color: #4a9eff;
            cursor: pointer;
            text-decoration: none;
            transition: color 0.2s;
        }
        
        .currently-playing.has-movie:hover {
            color: #5aaeff;
            text-decoration: underline;
        }
        
        .history-list {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, max-content));
            gap: 20px;
        }
        
        .history-item {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding-top: 15px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            align-items: flex-start;
        }
        
        .history-item:hover {
            background: #333;
        }
        
        .history-timestamp {
            font-size: 13px;
            color: #999;
            width: 100%;
        }
        
        .history-movie-card {
            width: 100%;
        }
    </style>
    <script src="star-rating.js"></script>
</head>
<body>
    <div id="app">
        <div class="controls" id="globalControls">
            <div style="display: flex; gap: 10px; align-items: center;">
                <a href="#/name-cleaning" class="nav-link" id="navNameCleaning">Name Cleaning</a>
                <a href="#/home" class="nav-link" id="navHome">Home</a>
                <a href="#/explore" class="nav-link" id="navExplore">Explore</a>
                <a href="#/history" class="nav-link" id="navHistory">History</a>
            </div>
            <div style="margin-left: auto; display: flex; gap: 10px; align-items: center;">
                <div id="statusMessage"></div>
                <div id="currentlyPlaying" class="currently-playing">nothing playing</div>
                <a href="#/setup" class="nav-link" id="navSetup">Setup</a>
            </div>
        </div>
        
        <!-- Name Cleaning Page -->
        <div class="page" id="pageNameCleaning">
            <h1>Name Cleaning</h1>
            <p style="margin-bottom: 20px; color: #aaa;">Review and approve patterns to clean from movie names. Patterns you approve will be automatically removed from movie names during indexing.</p>
            
            <div style="margin-bottom: 20px;">
                <button class="btn" onclick="loadCleaningPatterns()">Refresh Analysis</button>
                <button class="btn btn-success" onclick="saveCleaningPatterns()" style="margin-left: 10px;">Save Approved Patterns</button>
            </div>
            
            <div id="cleaningStatus" style="margin-bottom: 20px; padding: 10px; background: #2a2a2a; border-radius: 6px; display: none;"></div>
            
            <div id="cleaningPatternsContainer">
                <div style="text-align: center; padding: 40px; color: #666;">
                    Click "Refresh Analysis" to analyze movie names and find suspicious patterns.
                </div>
            </div>
        </div>
        
        <!-- Home Page -->
        <div class="page active" id="pageHome">
            <h1>Movie Searcher</h1>
            
            <div class="search-container">
                <input type="text" id="searchInput" placeholder="Search movies..." autocomplete="off">
                <div class="autocomplete" id="autocomplete"></div>
                <button class="clear-search-btn" id="clearSearchBtn" onclick="clearSearch()" style="display: none;">× Clear</button>
            </div>
            
             <div class="filter-options">
                 <div class="btn-group btn-group-toggle" role="group">
                     <button type="button" class="btn active" data-filter="all" onclick="setWatchFilter('all', this)">All</button>
                     <button type="button" class="btn" data-filter="watched" onclick="setWatchFilter('watched', this)">Watched only</button>
                     <button type="button" class="btn" data-filter="unwatched" onclick="setWatchFilter('unwatched', this)">Unwatched only</button>
                 </div>
             </div>
            
            <div class="results" id="results"></div>
            
            <div class="watched-section" id="watchedSection">
                <div class="section-title">Watched Movies</div>
                <button class="btn btn-secondary" id="viewWatchedBtn" onclick="toggleWatchedView()">View Watched</button>
                <div id="watchedList"></div>
            </div>
            
            <div class="stats" id="stats"></div>
        </div>
        
        <!-- Explore Page -->
        <div class="page" id="pageExplore">
            <h1>Explore Movies</h1>
            
            <div class="explore-filters">
                <label>
                    <input type="radio" name="exploreFilter" value="all" checked onchange="applyExploreFilters()">
                    All
                </label>
                <label>
                    <input type="radio" name="exploreFilter" value="watched" onchange="applyExploreFilters()">
                    Watched Only
                </label>
                <label>
                    <input type="radio" name="exploreFilter" value="unwatched" onchange="applyExploreFilters()">
                    Unwatched Only
                </label>
            </div>
            
            <div class="letter-nav" id="letterNav"></div>
            
            <div class="movie-grid" id="movieGrid"></div>
            
            <div class="pagination" id="explorePagination"></div>
        </div>
        
        <!-- Movie Details Page -->
        <div class="page" id="pageMovieDetails">
            <button class="back-button" onclick="navigateTo('/home')">← Back</button>
            <div class="movie-details-container" id="movieDetailsContainer">
                <div class="loading">Loading movie details...</div>
            </div>
        </div>
        
        <!-- History Page -->
        <div class="page" id="pageHistory">
            <h1>Launch History</h1>
            <div id="historyList" class="history-list"></div>
        </div>
        
        <!-- Setup Page -->
        <div class="page" id="pageSetup">
            <h1>Setup</h1>
            
            <div class="setup-section">
                <h3>Movies Folder</h3>
                <p>Configure the folder where your movies are stored. The application will scan this folder to index all video files.</p>
                <div class="folder-info" style="margin-bottom: 15px;">
                    <span>Current folder:</span>
                    <span class="folder-path" id="setupCurrentFolder">Loading...</span>
                </div>
                <button class="btn" id="setupChangeFolderBtn" onclick="showFolderDialog()">Change Movies Folder</button>
            </div>
            
            <div class="setup-section">
                <h3>Scan Movies</h3>
                <p>Scan your movies folder to index all video files. This will update the database with any new or changed files.</p>
                <button class="btn" id="setupScanBtn" onclick="scanFolder()">Scan Movies Folder</button>
                <div class="progress-container" id="setupProgressContainer" style="margin-top: 15px;">
                    <div class="progress-info">
                        <span id="setupProgressStatus">Preparing scan...</span>
                        <span id="setupProgressCount">0 / 0</span>
                    </div>
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="setupProgressBar" style="width: 0%">0%</div>
                    </div>
                    <div class="progress-file" id="setupProgressFile"></div>
                    <div class="scan-log-window" id="setupScanLogWindow" style="display: none;"></div>
                </div>
            </div>
            
            <div class="setup-section">
                <h3>VLC Settings</h3>
                <p>Configure how VLC media player behaves when launching movies.</p>
                <div class="setup-option">
                    <label>
                        <input type="checkbox" id="setupCloseExistingVlc" checked>
                        Close existing VLC windows when launching a new movie
                    </label>
                    <div class="setup-option-description">
                        When enabled, all existing VLC windows will be closed before launching a new movie. When disabled, new movies will open in addition to any existing VLC windows.
                    </div>
                </div>
            </div>
            
            <div class="setup-section">
                <h3>Statistics</h3>
                <div id="setupStats"></div>
            </div>
        </div>
    
    <div class="folder-dialog" id="folderDialog">
        <h3>Select Movies Folder</h3>
        <p style="margin-bottom: 10px; color: #999; font-size: 13px;">Enter the full path to your movies folder:</p>
        <input type="text" id="folderPathInput" placeholder="C:\Movies or D:\Movies\MyCollection" style="margin-bottom: 15px;" autofocus>
        <p style="margin-bottom: 15px; color: #777; font-size: 12px;">You can use forward slashes (/) or backslashes (\) - they will be converted automatically.</p>
        <div class="dialog-buttons">
            <button class="btn btn-secondary" onclick="hideFolderDialog()">Cancel</button>
            <button class="btn btn-success" onclick="saveFolderPath()">Save</button>
        </div>
    </div>
    
    <div class="media-overlay" id="mediaOverlay" onclick="closeMediaOverlay()">
        <div class="media-overlay-close" onclick="event.stopPropagation(); closeMediaOverlay();">×</div>
        <img id="mediaOverlayImage" onclick="event.stopPropagation();" alt="Full size image">
    </div>
    
    <script>
        // Routing
        function getRoute() {
            const hash = window.location.hash || '#/home';
            return hash.substring(1); // Remove #
        }
        
        function navigateTo(route) {
            window.location.hash = route;
            handleRoute();
        }
        
        function handleRoute() {
            const route = getRoute();
            const pages = document.querySelectorAll('.page');
            pages.forEach(page => page.classList.remove('active'));
            
            // Update nav links
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + route) {
                    link.classList.add('active');
                }
            });
            
            const pageHome = document.getElementById('pageHome');
            const pageExplore = document.getElementById('pageExplore');
            const pageSetup = document.getElementById('pageSetup');
            const pageMovieDetails = document.getElementById('pageMovieDetails');
            const pageHistory = document.getElementById('pageHistory');
            const pageNameCleaning = document.getElementById('pageNameCleaning');
            
            if (route === '/name-cleaning') {
                if (pageNameCleaning) {
                    pageNameCleaning.classList.add('active');
                    loadCleaningPatterns();
                }
            } else if (route === '/home' || route === '/') {
                 if (pageHome) pageHome.classList.add('active');
                 updateClearButtonVisibility();
             } else if (route === '/explore') {
                 if (pageExplore) {
                     pageExplore.classList.add('active');
                     exploreViewActive = true;
                     loadExploreMovies();
                 }
             } else if (route === '/history') {
                 if (pageHistory) {
                     pageHistory.classList.add('active');
                     loadHistory();
                 }
             } else if (route === '/setup') {
                 if (pageSetup) {
                     pageSetup.classList.add('active');
                     loadSetupPage();
                 }
             } else if (route.startsWith('/movie/')) {
                 const path = decodeURIComponent(route.substring(7));
                 if (pageMovieDetails) {
                     pageMovieDetails.classList.add('active');
                     loadMovieDetails(path);
                 }
             } else {
                 navigateTo('/home');
             }
        }
        
        window.addEventListener('hashchange', handleRoute);
        window.addEventListener('load', handleRoute);
        
        // Movie Card Component
        function createMovieCard(movie) {
            const imageUrl = movie.image ? `/api/image?image_path=${encodeURIComponent(movie.image)}` : '';
            const watchedClass = movie.watched ? 'watched' : '';
            const fileSize = movie.size ? formatSize(movie.size) : '';
            const year = movie.year ? movie.year : '';
            const length = movie.length ? formatTime(movie.length) : '';
            const hasLaunched = movie.has_launched || false;
            
            return `
                <div class="movie-card ${watchedClass}" onclick="navigateTo('/movie/${encodeURIComponent(movie.path)}')">
                    <div class="movie-card-image">
                        ${imageUrl ? `<img src="${imageUrl}" alt="${escapeHtml(movie.name)}" loading="lazy" onerror="this.parentElement.innerHTML='No Image'">` : 'No Image'}
                    </div>
                    <div class="movie-card-body">
                        <div class="movie-card-title">${escapeHtml(movie.name)}</div>
                        <div class="movie-card-meta">
                            ${year ? `<span>${year}</span>` : ''}
                            ${length ? `<span>${length}</span>` : ''}
                            ${fileSize ? `<span>${fileSize}</span>` : ''}
                            ${hasLaunched ? '<div class="launch-status-checkbox launched" onclick="event.stopPropagation();"></div>' : ''}
                        </div>
                        <div class="movie-card-buttons">
                            <button class="movie-card-btn" onclick="event.stopPropagation(); toggleWatched('${escapeJsString(movie.path)}', ${movie.watched})">
                                ${movie.watched ? '<span class="watched-checkbox"></span>' : ''}watched
                            </button>
                            ${renderStarRating(movie.path, movie.watched, movie.rating || null)}
                            <button class="movie-card-launch" onclick="event.stopPropagation(); launchMovie('${escapeJsString(movie.path)}')">▶</button>
                        </div>
                    </div>
                </div>
            `;
        }
        
        let selectedIndex = -1;
        let currentResults = [];
        let watchedViewActive = false;
        let exploreViewActive = false;
        let currentSubtitles = {};
        // Explore page state - only for tracking current page, not for building requests
        let currentExplorePage = 1;
        const EXPLORE_PER_PAGE = 24;
        // Request sequencing to handle out-of-order AJAX responses
        let searchRequestCounter = 0;
        let lastDisplayedRequestId = -1;
        
        const searchInput = document.getElementById('searchInput');
        const autocomplete = document.getElementById('autocomplete');
        const results = document.getElementById('results');
        const stats = document.getElementById('stats');
        const viewWatchedBtn = document.getElementById('viewWatchedBtn');
        const watchedSection = document.getElementById('watchedSection');
        const watchedList = document.getElementById('watchedList');
        function getWatchFilter() {
            const activeBtn = document.querySelector('.btn-group-toggle .btn.active');
            if (activeBtn) {
                return activeBtn.getAttribute('data-filter') || 'all';
            }
            return 'all';
        }
        
        function setWatchFilter(filterValue, clickedBtn) {
            // Remove active class from all buttons
            const buttons = document.querySelectorAll('.btn-group-toggle .btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            // Add active class to clicked button
            clickedBtn.classList.add('active');
            
            // Apply filters if there's a search query
            applyFilters();
        }
        const statusMessage = document.getElementById('statusMessage');
        let progressInterval = null;
        
        function showStatus(message, type = 'info') {
            statusMessage.innerHTML = `<div class="status-message ${type}">${escapeHtml(message)}</div>`;
            setTimeout(() => {
                statusMessage.innerHTML = '';
            }, 5000);
        }
        
        function formatTime(seconds) {
            if (!seconds) return 'Unknown';
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            if (h > 0) return `${h}h ${m}m`;
            return `${m}m ${s}s`;
        }
        
        function formatDate(dateStr) {
            if (!dateStr) return '';
            const date = new Date(dateStr);
            return date.toLocaleDateString();
        }
        
        function formatSize(bytes) {
            if (!bytes) return '';
            const gb = bytes / (1024 * 1024 * 1024);
            if (gb >= 1) return `${gb.toFixed(2)} GB`;
            const mb = bytes / (1024 * 1024);
            return `${mb.toFixed(2)} MB`;
        }
        
        async function scanFolder() {
            const btn = document.getElementById('setupScanBtn') || document.getElementById('scanBtn');
            const progressContainer = document.getElementById('setupProgressContainer') || document.getElementById('progressContainer');
            const progressBar = document.getElementById('setupProgressBar') || document.getElementById('progressBar');
            const progressStatus = document.getElementById('setupProgressStatus') || document.getElementById('progressStatus');
            const progressCount = document.getElementById('setupProgressCount') || document.getElementById('progressCount');
            const progressFile = document.getElementById('setupProgressFile') || document.getElementById('progressFile');
            
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Scanning...';
            }
            if (progressContainer) {
                progressContainer.classList.add('active');
            }
            showStatus('Starting scan...', 'info');
            
            try {
                const response = await fetch('/api/index', { method: 'POST' });
                const data = await response.json();
                
                if (response.ok) {
                    // Start polling for progress
                    startProgressPolling(progressContainer, progressBar, progressStatus, progressCount, progressFile, btn);
                } else {
                    showStatus('Scan failed: ' + (data.detail || 'Unknown error'), 'error');
                    if (progressContainer) progressContainer.classList.remove('active');
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = 'Scan Movies Folder';
                    }
                }
            } catch (error) {
                showStatus('Scan failed: ' + error.message, 'error');
                if (progressContainer) progressContainer.classList.remove('active');
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Scan Movies Folder';
                }
            }
        }
        
        let lastLogCount = 0;
        
        function renderLogs(logWindow, logs) {
            if (!logWindow || !logs) return;
            
            // Only append new logs
            if (logs.length > lastLogCount) {
                const newLogs = logs.slice(lastLogCount);
                newLogs.forEach(log => {
                    const logEntry = document.createElement('div');
                    logEntry.className = `log-entry ${log.level}`;
                    
                    const timestamp = document.createElement('span');
                    timestamp.className = 'log-timestamp';
                    timestamp.textContent = log.timestamp;
                    
                    const level = document.createElement('span');
                    level.className = 'log-level';
                    level.textContent = `[${log.level.toUpperCase()}]`;
                    
                    const message = document.createElement('span');
                    message.textContent = log.message;
                    
                    logEntry.appendChild(timestamp);
                    logEntry.appendChild(level);
                    logEntry.appendChild(message);
                    logWindow.appendChild(logEntry);
                });
                
                // Auto-scroll to bottom
                logWindow.scrollTop = logWindow.scrollHeight;
                lastLogCount = logs.length;
            }
        }
        
        function startProgressPolling(progressContainer, progressBar, progressStatus, progressCount, progressFile, scanBtn) {
            if (progressInterval) {
                clearInterval(progressInterval);
            }
            
            // Reset log counter
            lastLogCount = 0;
            
            // Find log window
            const logWindow = document.getElementById('setupScanLogWindow') || document.getElementById('scanLogWindow');
            if (logWindow) {
                logWindow.innerHTML = '';
                logWindow.style.display = 'block';
            }
            
            progressInterval = setInterval(async () => {
                try {
                    const response = await fetch('/api/scan-progress');
                    const data = await response.json();
                    
                    if (data.is_scanning) {
                        const percent = Math.round(data.progress_percent);
                        if (progressBar) {
                            progressBar.style.width = percent + '%';
                            progressBar.textContent = percent + '%';
                        }
                        if (progressCount) progressCount.textContent = `${data.current} / ${data.total}`;
                        if (progressFile) progressFile.textContent = data.current_file ? `Scanning: ${data.current_file}` : '';
                        
                        if (progressStatus) {
                            if (data.status === 'counting') {
                                progressStatus.textContent = 'Counting files...';
                            } else if (data.status === 'scanning') {
                                progressStatus.textContent = 'Scanning movies...';
                            } else {
                                progressStatus.textContent = data.status;
                            }
                        }
                        
                        // Render logs
                        if (data.logs && logWindow) {
                            renderLogs(logWindow, data.logs);
                        }
                    } else {
                        // Scan complete
                        clearInterval(progressInterval);
                        progressInterval = null;
                        // Keep progress container visible to show scan logs
                        // Don't remove 'active' class so log window remains visible
                        if (scanBtn) {
                            scanBtn.disabled = false;
                            scanBtn.textContent = 'Scan Movies Folder';
                        }
                        
                        // Final log render
                        if (data.logs && logWindow) {
                            renderLogs(logWindow, data.logs);
                        }
                        
                        // Update progress status to show completion
                        if (progressStatus) {
                            if (data.status === 'complete') {
                                progressStatus.textContent = `Scan complete: ${data.current} movies indexed`;
                                if (progressBar) {
                                    progressBar.style.width = '100%';
                                    progressBar.textContent = '100%';
                                }
                                if (progressFile) progressFile.textContent = '';
                            } else if (data.status.startsWith('error')) {
                                progressStatus.textContent = 'Scan error: ' + data.status;
                            }
                        }
                        
                        if (data.status === 'complete') {
                            showStatus(`Scan complete: ${data.current} movies indexed`, 'success');
                            loadStats();
                            // Reload setup stats if on setup page
                            const route = getRoute();
                            if (route === '/setup') {
                                loadSetupPage();
                            }
                        } else if (data.status.startsWith('error')) {
                            showStatus('Scan error: ' + data.status, 'error');
                        }
                    }
                } catch (error) {
                    console.error('Progress polling error:', error);
                }
            }, 500); // Poll every 500ms
        }
        
        async function search(query) {
            if (query.length < 1) {
                autocomplete.style.display = 'none';
                if (!watchedViewActive) {
                    results.innerHTML = '';
                }
                return;
            }
            
            // Increment request counter for this search
            searchRequestCounter++;
            const requestId = searchRequestCounter;
            
            try {
                const filterType = getWatchFilter();
                const response = await fetch(`/api/search?q=${encodeURIComponent(query)}&filter_type=${filterType}`);
                const data = await response.json();
                
                // Only display results if this response is from the latest request or newer than what's displayed
                if (requestId > lastDisplayedRequestId) {
                    lastDisplayedRequestId = requestId;
                    currentResults = data.results || [];
                    displayAutocomplete(currentResults);
                }
                // Otherwise, silently discard this stale response
            } catch (error) {
                console.error('Search error:', error);
            }
        }
        
        function applyFilters() {
            if (searchInput.value.length > 0) {
                search(searchInput.value);
            }
        }
        
        function clearSearch() {
            searchInput.value = '';
            autocomplete.style.display = 'none';
            results.innerHTML = '';
            currentResults = [];
            searchRequestCounter = 0;
            lastDisplayedRequestId = -1;
            updateClearButtonVisibility();
            searchInput.focus();
        }
        
        function updateClearButtonVisibility() {
            const clearBtn = document.getElementById('clearSearchBtn');
            if (clearBtn) {
                clearBtn.style.display = searchInput.value.length > 0 ? 'inline-block' : 'none';
            }
        }
        
        function displayAutocomplete(items) {
            if (items.length === 0) {
                autocomplete.style.display = 'none';
                return;
            }
            
            autocomplete.innerHTML = items.slice(0, 10).map((item, index) => `
                <div class="autocomplete-item" data-index="${index}">
                    <span class="movie-name">
                        ${escapeHtml(item.name)}
                        ${item.watched ? '<span class="watched-badge">Watched</span>' : ''}
                    </span>
                    <span class="movie-meta">
                        ${item.length ? formatTime(item.length) : ''}
                        ${item.created ? ' • ' + formatDate(item.created) : ''}
                    </span>
                </div>
            `).join('');
            
            autocomplete.style.display = 'block';
            selectedIndex = -1;
        }
        
        async function loadSubtitles(videoPath) {
            if (currentSubtitles[videoPath]) {
                return currentSubtitles[videoPath];
            }
            
            try {
                const response = await fetch(`/api/subtitles?video_path=${encodeURIComponent(videoPath)}`);
                const data = await response.json();
                currentSubtitles[videoPath] = data.subtitles || [];
                return currentSubtitles[videoPath];
            } catch (error) {
                console.error('Subtitle error:', error);
                return [];
            }
        }
        
        function renderMediaGallery(images, screenshots, itemPath) {
            const allMedia = [];
            
            // Add folder images first
            if (images && images.length > 0) {
                images.forEach((img, idx) => {
                    allMedia.push({
                        path: img,
                        type: 'image',
                        label: idx === 0 ? 'Poster' : `Image ${idx + 1}`
                    });
                });
            }
            
            // Add screenshots
            if (screenshots && screenshots.length > 0) {
                screenshots.forEach((screenshot, idx) => {
                    allMedia.push({
                        path: screenshot,
                        type: 'screenshot',
                        label: `Screenshot ${idx + 1}`
                    });
                });
            }
            
            if (allMedia.length === 0) {
                return '';
            }
            
            // Show first image larger, rest as thumbnails
            const firstMedia = allMedia[0];
            const restMedia = allMedia.slice(1, 6); // Limit to 5 more
            
            let galleryHtml = '<div class="media-gallery">';
            
            // First image (larger)
            galleryHtml += `
                <div class="media-item large" onclick="showMediaOverlay('${escapeHtml(firstMedia.path)}')">
                    <img src="/api/image?image_path=${encodeURIComponent(firstMedia.path)}" 
                         alt="${escapeHtml(firstMedia.label)}" 
                         loading="lazy"
                         onerror="this.style.display='none'">
                    <div class="media-label">${escapeHtml(firstMedia.label)}</div>
                </div>
            `;
            
            // Rest as thumbnails
            restMedia.forEach(media => {
                galleryHtml += `
                    <div class="media-item" onclick="showMediaOverlay('${escapeHtml(media.path)}')">
                        <img src="/api/image?image_path=${encodeURIComponent(media.path)}" 
                             alt="${escapeHtml(media.label)}" 
                             loading="lazy"
                             onerror="this.style.display='none'">
                        <div class="media-label">${escapeHtml(media.label)}</div>
                    </div>
                `;
            });
            
            galleryHtml += '</div>';
            return galleryHtml;
        }
        
        function showMediaOverlay(imagePath) {
            const overlay = document.getElementById('mediaOverlay');
            const img = document.getElementById('mediaOverlayImage');
            img.src = `/api/image?image_path=${encodeURIComponent(imagePath)}`;
            overlay.classList.add('active');
        }
        
        function closeMediaOverlay() {
            const overlay = document.getElementById('mediaOverlay');
            overlay.classList.remove('active');
        }
        
        async function displayResults(items) {
            if (items.length === 0) {
                results.innerHTML = '<div class="empty-state">No results found</div>';
                return;
            }
            
            // Display as movie cards in a grid
            results.innerHTML = '<div class="movie-grid">' + items.map(item => createMovieCard(item)).join('') + '</div>';
        }
        
        async function updateSubtitle(videoPath, subtitlePath) {
            // Store subtitle selection for this video
            if (!currentSubtitles[videoPath]) {
                currentSubtitles[videoPath] = [];
            }
        }
        
        async function launchMovie(path) {
            try {
                const subtitleSelect = document.getElementById(`subtitle-${escapeHtml(path)}`);
                const subtitlePath = subtitleSelect ? subtitleSelect.value : null;
                const closeExistingVlc = document.getElementById('setupCloseExistingVlc').checked;
                
                const response = await fetch('/api/launch', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        path: path, 
                        subtitle_path: subtitlePath || null,
                        close_existing_vlc: closeExistingVlc
                    })
                });
                
                let data;
                try {
                    data = await response.json();
                } catch (e) {
                    throw new Error('Invalid response from server');
                }
                
                if (!response.ok) {
                    const errorMsg = data.detail || data.message || 'Launch failed';
                    showStatus('Launch failed: ' + errorMsg, 'error');
                    return;
                }
                
                if (data.status === 'launched') {
                    showStatus('Movie launched successfully', 'success');
                } else {
                    showStatus('Launch failed: ' + (data.detail || 'Unknown error'), 'error');
                }
            } catch (error) {
                const errorMsg = 'Failed to launch movie: ' + error.message;
                showStatus(errorMsg, 'error');
            }
        }
        
        function generateExternalLinks(movieName) {
            // Clean up movie name - remove common patterns like year, quality, etc.
            let cleanName = movieName
                .replace(/\s*\(\d{4}\)\s*$/, '') // Remove year in parentheses at end
                .replace(/\s*\d{4}\s*$/, '') // Remove year at end
                .replace(/\s*-\s*\d{4}\s*$/, '') // Remove dash year at end
                .replace(/\s*\[.*?\]\s*/g, '') // Remove brackets content
                .replace(/\s*\(.*?\)\s*/g, '') // Remove parentheses content
                .replace(/\s*1080p|\s*720p|\s*480p|\s*4K|\s*BluRay|\s*DVDRip|\s*WEBRip|\s*x264|\s*x265/gi, '') // Remove quality tags
                .replace(/\s*S\d{2}E\d{2}/gi, '') // Remove episode numbers
                .replace(/\s*Season\s*\d+/gi, '') // Remove season numbers
                .trim();
            
            // URL encode the cleaned name
            const encodedName = encodeURIComponent(cleanName);
            const encodedNameSpaces = encodeURIComponent(cleanName.replace(/\s+/g, '-').toLowerCase());
            
            return {
                letterboxd: `https://letterboxd.com/search/${encodedNameSpaces}/`,
                wikipedia: `https://en.wikipedia.org/wiki/Special:Search/${encodedName}`,
                imdb: `https://www.imdb.com/find?q=${encodedName}`,
                tmdb: `https://www.themoviedb.org/search?query=${encodedName}`,
                google: `https://www.google.com/search?q=${encodedName}+movie`
            };
        }
        
        async function openFolder(path) {
            try {
                const response = await fetch(`/api/open-folder?path=${encodeURIComponent(path)}`, {
                    method: 'POST'
                });
                const data = await response.json();
                if (response.ok) {
                    showStatus('Folder opened', 'success');
                } else {
                    showStatus('Failed to open folder: ' + (data.detail || 'Unknown error'), 'error');
                }
            } catch (error) {
                showStatus('Failed to open folder: ' + error.message, 'error');
            }
        }
        
        async function toggleWatched(path, currentWatched = null) {
            try {
                // If currentWatched is null, determine from current results or fetch
                if (currentWatched === null) {
                    // Try to find in current results first
                    const currentItem = currentResults.find(r => r.path === path);
                    if (currentItem) {
                        currentWatched = currentItem.watched || false;
                    } else {
                        // Fallback: check watched list
                        const watchedData = await fetch('/api/watched').then(r => r.json());
                        currentWatched = watchedData.watched.some(w => typeof w === 'string' ? w === path : w.path === path);
                    }
                }
                
                // Toggle to opposite state
                const newWatched = !currentWatched;
                
                const response = await fetch('/api/watched', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({path: path, watched: newWatched})
                });
                
                if (response.ok) {
                    // Refresh current view
                    if (watchedViewActive) {
                        loadWatchedMovies();
                    } else if (exploreViewActive) {
                        loadExploreMovies();
                    } else if (searchInput.value.length > 0) {
                        search(searchInput.value);
                    }
                    loadStats();
                }
            } catch (error) {
                showStatus('Failed to update watched status: ' + error.message, 'error');
            }
        }
        
        // Star rating functions are now in star-rating.js
        
        async function setRating(path, rating) {
            // Setting a rating automatically marks as watched
            try {
                const response = await fetch('/api/watched', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({path: path, watched: true, rating: rating})
                });
                
                if (response.ok) {
                    if (watchedViewActive) {
                        loadWatchedMovies();
                    } else if (exploreViewActive) {
                        loadExploreMovies();
                    } else if (searchInput.value.length > 0) {
                        search(searchInput.value);
                    }
                    loadStats();
                }
            } catch (error) {
                showStatus('Failed to update rating: ' + error.message, 'error');
            }
        }
        
        async function loadWatchedMovies() {
            try {
                const response = await fetch('/api/watched');
                const data = await response.json();
                const watched = data.watched || [];
                
                if (watched.length === 0) {
                    watchedList.innerHTML = '<div class="empty-state">No watched movies yet</div>';
                    return;
                }
                
                watchedList.innerHTML = '<div class="movie-grid">' + watched.map(item => createMovieCard(item)).join('') + '</div>';
            } catch (error) {
                console.error('Watched movies error:', error);
                watchedList.innerHTML = '<div class="empty-state">Error loading watched movies</div>';
            }
        }
        
        function toggleWatchedView() {
            if (exploreViewActive) {
                toggleExploreView();
            }
            
            watchedViewActive = !watchedViewActive;
            
            if (watchedViewActive) {
                watchedSection.classList.add('active');
                viewWatchedBtn.textContent = 'Hide Watched';
                results.style.display = 'none';
                loadWatchedMovies();
            } else {
                watchedSection.classList.remove('active');
                viewWatchedBtn.textContent = 'View Watched';
                results.style.display = 'block';
            }
        }
        
        function toggleExploreView() {
            navigateTo('/explore');
        }
        
        // Standard AJAX pattern: read UI state, build request, fetch, update UI
        function getCurrentExploreFilters() {
            // Read filter type from radio buttons
            const filterRadios = document.querySelectorAll('input[name="exploreFilter"]');
            let filterType = 'all';
            for (const radio of filterRadios) {
                if (radio.checked) {
                    filterType = radio.value;
                    break;
                }
            }
            
            // Read letter from active letter button
            const activeLetterBtn = document.querySelector('.letter-btn.active[data-letter]');
            const letter = activeLetterBtn ? activeLetterBtn.dataset.letter : null;
            
            return { filterType, letter };
        }
        
        async function fetchExploreMovies(page, filterType, letter) {
            try {
                const params = new URLSearchParams({
                    page: page.toString(),
                    per_page: EXPLORE_PER_PAGE.toString(),
                    filter_type: filterType
                });
                
                if (letter) {
                    params.append('letter', letter);
                }
                
                const url = `/api/explore?${params}`;
                console.log('fetchExploreMovies called with:', { page, filterType, letter });
                console.log('Request URL:', url);
                const response = await fetch(url);
                const data = await response.json();
                
                if (!response.ok) {
                    showStatus('Failed to load movies: ' + (data.detail || 'Unknown error'), 'error');
                    return;
                }
                
                // Update current page
                currentExplorePage = page;
                
                // Render letter navigation with current filter state
                renderLetterNav(data.letter_counts, letter);
                
                // Render movie grid
                renderMovieGrid(data.movies || []);
                
                // Render pagination
                renderPagination(data.pagination, filterType, letter);
                
            } catch (error) {
                showStatus('Error loading movies: ' + error.message, 'error');
                console.error('Explore error:', error);
            }
        }
        
        // Filter change handlers - read UI state and make request
        function applyExploreFilters() {
            const { filterType, letter } = getCurrentExploreFilters();
            // Reset to page 1 when filter changes, clear letter filter
            fetchExploreMovies(1, filterType, null);
        }
        
        function jumpToLetter(letter) {
            const { filterType } = getCurrentExploreFilters();
            fetchExploreMovies(1, filterType, letter);
        }
        
        function clearLetterFilter() {
            const { filterType } = getCurrentExploreFilters();
            fetchExploreMovies(1, filterType, null);
        }
        
        function goToExplorePage(page) {
            const { filterType, letter } = getCurrentExploreFilters();
            fetchExploreMovies(page, filterType, letter);
        }
        
        // Initial load - reads UI state
        function loadExploreMovies() {
            const { filterType, letter } = getCurrentExploreFilters();
            fetchExploreMovies(currentExplorePage || 1, filterType, letter);
        }
        
        function renderLetterNav(letterCounts, activeLetter) {
            const letterNav = document.getElementById('letterNav');
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
            
            let html = '';
            
            // Add "All" button
            const allCount = Object.values(letterCounts).reduce((sum, count) => sum + count, 0);
            html += `<button class="letter-btn ${!activeLetter ? 'active' : ''}" data-action="clear">All (${allCount})</button>`;
            
            // Add letter buttons
            for (const letter of letters) {
                const count = letterCounts[letter] || 0;
                const isActive = activeLetter === letter;
                html += `<button class="letter-btn ${isActive ? 'active' : ''}" ${count === 0 ? 'disabled' : ''} data-letter="${letter}">${letter} (${count})</button>`;
            }
            
            // Add "#" for non-alphabetic
            const hashCount = letterCounts['#'] || 0;
            const isHashActive = activeLetter === '#';
            html += `<button class="letter-btn ${isHashActive ? 'active' : ''}" ${hashCount === 0 ? 'disabled' : ''} data-letter="#"># (${hashCount})</button>`;
            
            letterNav.innerHTML = html;
            
            // Attach event listeners to all letter buttons
            letterNav.querySelectorAll('.letter-btn').forEach(btn => {
                if (btn.disabled) {
                    return;
                }
                
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (btn.dataset.action === 'clear') {
                        clearLetterFilter();
                    } else if (btn.dataset.letter) {
                        jumpToLetter(btn.dataset.letter);
                    }
                });
            });
        }
        
        function renderMovieGrid(movies) {
            const movieGrid = document.getElementById('movieGrid');
            
            if (!movieGrid) {
                console.error('movieGrid element not found');
                return;
            }
            
            // Always clear the grid first
            movieGrid.innerHTML = '';
            
            if (!movies || movies.length === 0) {
                console.log('No movies to render, showing empty state');
                movieGrid.innerHTML = '<div class="empty-state">No movies found</div>';
                return;
            }
            
            console.log('Rendering movie grid with', movies.length, 'movies');
            console.log('First 3 movie names:', movies.slice(0, 3).map(m => m.name));
            
            movieGrid.innerHTML = movies.map(movie => createMovieCard(movie)).join('');
            
            console.log('Grid now has', movieGrid.children.length, 'children');
        }
        
        async function loadMovieDetails(path) {
            const container = document.getElementById('movieDetailsContainer');
            container.innerHTML = '<div class="loading">Loading movie details...</div>';
            
            try {
                const response = await fetch(`/api/movie?path=${encodeURIComponent(path)}`);
                const movie = await response.json();
                
                if (!response.ok) {
                    container.innerHTML = `<div class="empty-state">Error: ${movie.detail || 'Failed to load movie'}</div>`;
                    return;
                }
                
                const imageUrl = movie.image ? `/api/image?image_path=${encodeURIComponent(movie.image)}` : '';
                const externalLinks = generateExternalLinks(movie.name);
                const mediaGallery = renderMediaGallery(movie.images || [], movie.screenshots || [], movie.path);
                
                // Load subtitles
                await loadSubtitles(movie.path);
                const subtitles = currentSubtitles[movie.path] || [];
                let subtitleSelect = '';
                if (subtitles.length > 0) {
                    subtitleSelect = `
                        <select class="subtitle-select" id="subtitle-${escapeHtml(movie.path)}" onchange="updateSubtitle('${escapeJsString(movie.path)}', this.value)">
                            <option value="">No subtitle</option>
                            ${subtitles.map(sub => `<option value="${escapeJsString(sub.path)}">${escapeHtml(sub.name)}</option>`).join('')}
                        </select>
                    `;
                }
                
                container.innerHTML = `
                    <div class="movie-details-header">
                        <div class="movie-details-poster">
                            ${imageUrl ? `<img src="${imageUrl}" alt="${escapeHtml(movie.name)}">` : 'No Image'}
                        </div>
                        <div class="movie-details-info">
                            <h1 class="movie-details-title">${escapeHtml(movie.name)}</h1>
                            <div class="movie-details-meta">
                                ${movie.year ? `<span>${movie.year}</span>` : ''}
                                ${movie.length ? `<span>${formatTime(movie.length)}</span>` : ''}
                                ${movie.size ? `<span>${formatSize(movie.size)}</span>` : ''}
                                ${movie.watched_date ? `<span>Watched: ${formatDate(movie.watched_date)}</span>` : ''}
                            </div>
                            <div class="movie-details-actions">
                                ${renderStarRating(movie.path, movie.watched, movie.rating)}
                                <button class="watched-btn ${movie.watched ? 'watched' : ''}" onclick="toggleWatched('${escapeJsString(movie.path)}', ${movie.watched})">
                                    ${movie.watched ? '✓ Watched' : 'Mark Watched'}
                                </button>
                                ${subtitleSelect}
                                <button class="launch-btn" onclick="launchMovie('${escapeJsString(movie.path)}')">Launch</button>
                            </div>
                            <div class="external-links" style="margin-top: 20px;">
                                <a href="${externalLinks.letterboxd}" target="_blank" class="external-link">Letterboxd</a>
                                <a href="${externalLinks.wikipedia}" target="_blank" class="external-link">Wikipedia</a>
                                <a href="${externalLinks.imdb}" target="_blank" class="external-link">IMDb</a>
                                <a href="${externalLinks.tmdb}" target="_blank" class="external-link">TMDB</a>
                                <a href="${externalLinks.google}" target="_blank" class="external-link">Google</a>
                                <a href="#" onclick="event.preventDefault(); openFolder('${escapeJsString(movie.path)}'); return false;" class="external-link">Open Folder</a>
                            </div>
                            <div style="margin-top: 20px; color: #999; font-size: 12px;">
                                <div>Path: ${escapeHtml(movie.path)}</div>
                                ${movie.created ? `<div>Created: ${formatDate(movie.created)}</div>` : ''}
                            </div>
                        </div>
                    </div>
                    ${mediaGallery}
                `;
            } catch (error) {
                container.innerHTML = `<div class="empty-state">Error loading movie: ${error.message}</div>`;
            }
        }
        
        function renderPagination(pagination, filterType, letter) {
            const paginationEl = document.getElementById('explorePagination');
            
            if (pagination.pages <= 1) {
                paginationEl.innerHTML = '';
                return;
            }
            
            let html = '';
            
            // Previous button
            const prevPage = pagination.page - 1;
            html += `<button class="pagination-btn" ${pagination.page === 1 ? 'disabled' : ''} onclick="goToExplorePage(${prevPage})">Previous</button>`;
            
            // Page numbers
            const maxPages = 10;
            let startPage = Math.max(1, pagination.page - Math.floor(maxPages / 2));
            let endPage = Math.min(pagination.pages, startPage + maxPages - 1);
            
            if (endPage - startPage < maxPages - 1) {
                startPage = Math.max(1, endPage - maxPages + 1);
            }
            
            if (startPage > 1) {
                html += `<button class="pagination-btn" onclick="goToExplorePage(1)">1</button>`;
                if (startPage > 2) {
                    html += `<span class="pagination-info">...</span>`;
                }
            }
            
            for (let i = startPage; i <= endPage; i++) {
                const isActive = i === pagination.page;
                html += `<button class="pagination-btn ${isActive ? 'active' : ''}" onclick="goToExplorePage(${i})">${i}</button>`;
            }
            
            if (endPage < pagination.pages) {
                if (endPage < pagination.pages - 1) {
                    html += `<span class="pagination-info">...</span>`;
                }
                html += `<button class="pagination-btn" onclick="goToExplorePage(${pagination.pages})">${pagination.pages}</button>`;
            }
            
            // Next button
            const nextPage = pagination.page + 1;
            html += `<button class="pagination-btn" ${pagination.page === pagination.pages ? 'disabled' : ''} onclick="goToExplorePage(${nextPage})">Next</button>`;
            
            // Page info
            html += `<span class="pagination-info">Page ${pagination.page} of ${pagination.pages} (${pagination.total} total)</span>`;
            
            paginationEl.innerHTML = html;
        }
        
        async function loadStats() {
            try {
                const response = await fetch('/api/stats');
                const data = await response.json();
                const pathCount = Array.isArray(data.indexed_paths) ? data.indexed_paths.length : 0;
                if (stats) {
                    stats.innerHTML = `
                        <div>Indexed: ${data.total_movies} movies from ${pathCount} path(s)</div>
                        <div>Watched: ${data.watched_count || 0} movies</div>
                    `;
                }
                return data;
            } catch (error) {
                console.error('Stats error:', error);
                return null;
            }
        }
        
        async function loadCurrentFolder() {
            try {
                const response = await fetch('/api/config');
                const data = await response.json();
                const folderPath = data.movies_folder || data.default_folder || 'Not set';
                const currentFolderEl = document.getElementById('currentFolder');
                const setupCurrentFolderEl = document.getElementById('setupCurrentFolder');
                if (currentFolderEl) currentFolderEl.textContent = folderPath;
                if (setupCurrentFolderEl) setupCurrentFolderEl.textContent = folderPath;
            } catch (error) {
                console.error('Config error:', error);
                const currentFolderEl = document.getElementById('currentFolder');
                const setupCurrentFolderEl = document.getElementById('setupCurrentFolder');
                if (currentFolderEl) currentFolderEl.textContent = 'Error loading';
                if (setupCurrentFolderEl) setupCurrentFolderEl.textContent = 'Error loading';
            }
        }
        
        async function loadSetupPage() {
            await loadCurrentFolder();
            const statsData = await loadStats();
            const setupStatsEl = document.getElementById('setupStats');
            if (setupStatsEl && statsData) {
                const pathCount = Array.isArray(statsData.indexed_paths) ? statsData.indexed_paths.length : 0;
                setupStatsEl.innerHTML = `
                    <div style="color: #e0e0e0; margin-bottom: 10px;">
                        <div style="margin-bottom: 5px;">Indexed: <strong>${statsData.total_movies}</strong> movies from <strong>${pathCount}</strong> path(s)</div>
                        <div>Watched: <strong>${statsData.watched_count || 0}</strong> movies</div>
                    </div>
                `;
            }
        }
        
        function normalizePath(path) {
            // Normalize path separators for Windows
            // Convert forward slashes to backslashes, handle double backslashes
            if (!path) return path;
            
            // Replace forward slashes with backslashes
            path = path.replace(/\//g, '\\');
            
            // Normalize double backslashes (but preserve UNC paths like \\server\share)
            // Only normalize if it's not at the start (UNC path)
            if (path.startsWith('\\\\') && path.length > 2) {
                // UNC path - keep the first two backslashes, normalize the rest
                const rest = path.substring(2).replace(/\\\\+/g, '\\');
                path = '\\\\' + rest;
            } else {
                // Regular path - normalize all double+ backslashes
                path = path.replace(/\\\\+/g, '\\');
            }
            
            // Remove trailing backslash (unless it's a root like C:\)
            if (path.length > 3 && path.endsWith('\\') && path.match(/^[A-Za-z]:\\$/)) {
                // Keep it - it's a drive root
            } else if (path.endsWith('\\')) {
                path = path.slice(0, -1);
            }
            
            return path;
        }
        
        function showFolderDialog() {
            const dialog = document.getElementById('folderDialog');
            const input = document.getElementById('folderPathInput');
            
            // Load current path into input
            loadCurrentFolder().then(() => {
                const setupCurrentFolderEl = document.getElementById('setupCurrentFolder');
                const currentPath = setupCurrentFolderEl ? setupCurrentFolderEl.textContent : '';
                if (currentPath && currentPath !== 'Loading...' && currentPath !== 'Error loading' && currentPath !== 'Not set') {
                    input.value = currentPath;
                } else {
                    input.value = '';
                }
            });
            
            dialog.classList.add('active');
            // Focus the input after a short delay to ensure dialog is visible
            setTimeout(() => {
                input.focus();
                input.select();
            }, 100);
        }
        
        function hideFolderDialog() {
            const dialog = document.getElementById('folderDialog');
            dialog.classList.remove('active');
        }
        
        async function saveFolderPath() {
            const input = document.getElementById('folderPathInput');
            let folderPath = input.value.trim();
            
            if (!folderPath) {
                showStatus('Please enter a folder path', 'error');
                return;
            }
            
            // Normalize the path (handle /, \, \\)
            folderPath = normalizePath(folderPath);
            
            try {
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({movies_folder: folderPath})
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    showStatus('Movies folder updated successfully', 'success');
                    loadCurrentFolder();
                    loadStats();
                    hideFolderDialog();
                } else {
                    showStatus('Failed to update folder: ' + (data.detail || 'Unknown error'), 'error');
                }
            } catch (error) {
                showStatus('Failed to update folder: ' + error.message, 'error');
            }
        }
        
        // Allow Enter key to save in folder dialog, ESC to close media overlay
        document.addEventListener('keydown', (e) => {
            const dialog = document.getElementById('folderDialog');
            const overlay = document.getElementById('mediaOverlay');
            
            if (dialog.classList.contains('active')) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveFolderPath();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    hideFolderDialog();
                }
            } else if (overlay.classList.contains('active')) {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    closeMediaOverlay();
                }
            }
        });
        
        // Close dialog when clicking outside
        document.addEventListener('click', (e) => {
            const dialog = document.getElementById('folderDialog');
            if (dialog.classList.contains('active') && e.target === dialog) {
                hideFolderDialog();
            }
        });
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function escapeJsString(text) {
            // Escape for JavaScript string literals - backslashes and quotes
            return text
                .replace(/\\/g, '\\\\')  // Escape backslashes
                .replace(/'/g, "\\'")    // Escape single quotes
                .replace(/"/g, '\\"');    // Escape double quotes
        }
        
        searchInput.addEventListener('input', (e) => {
            const route = getRoute();
            updateClearButtonVisibility();
            if (route === '/home' || route === '/') {
                search(e.target.value);
            }
        });
        
        searchInput.addEventListener('keydown', (e) => {
            const route = getRoute();
            if (route !== '/home' && route !== '/') return;
            
            const items = autocomplete.querySelectorAll('.autocomplete-item');
            
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                updateSelection(items);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedIndex = Math.max(selectedIndex - 1, -1);
                updateSelection(items);
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedIndex >= 0 && items[selectedIndex]) {
                    const item = currentResults[selectedIndex];
                    searchInput.value = item.name;
                    autocomplete.style.display = 'none';
                    displayResults([item]);
                    updateClearButtonVisibility();
                } else if (currentResults.length > 0) {
                    displayResults(currentResults);
                    autocomplete.style.display = 'none';
                    updateClearButtonVisibility();
                }
            } else if (e.key === 'Escape') {
                autocomplete.style.display = 'none';
            }
        });
        
        function updateSelection(items) {
            items.forEach((item, index) => {
                if (index === selectedIndex) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
        }
        
        autocomplete.addEventListener('click', (e) => {
            const item = e.target.closest('.autocomplete-item');
            if (item) {
                const index = parseInt(item.dataset.index);
                const movie = currentResults[index];
                searchInput.value = movie.name;
                autocomplete.style.display = 'none';
                displayResults([movie]);
                updateClearButtonVisibility();
            }
        });
        
        // loadCurrentFolder is already defined above - removed duplicate
        
        function showFolderDialog() {
            const dialog = document.getElementById('folderDialog');
            const input = document.getElementById('folderPathInput');
            
            // Load current path into input
            loadCurrentFolder().then(() => {
                const setupCurrentFolderEl = document.getElementById('setupCurrentFolder');
                const currentPath = setupCurrentFolderEl ? setupCurrentFolderEl.textContent : '';
                if (currentPath && currentPath !== 'Loading...' && currentPath !== 'Error loading' && currentPath !== 'Not set') {
                    input.value = currentPath;
                } else {
                    input.value = '';
                }
            });
            
            dialog.classList.add('active');
        }
        
        function hideFolderDialog() {
            const dialog = document.getElementById('folderDialog');
            dialog.classList.remove('active');
        }
        
        async function saveFolderPath() {
            const input = document.getElementById('folderPathInput');
            let folderPath = input.value.trim();
            
            if (!folderPath) {
                showStatus('Please enter a folder path', 'error');
                return;
            }
            
            // Normalize the path (handle /, \, \\)
            folderPath = normalizePath(folderPath);
            
            try {
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({movies_folder: folderPath})
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    showStatus('Movies folder updated successfully', 'success');
                    loadCurrentFolder();
                    loadStats();
                    hideFolderDialog();
                } else {
                    showStatus('Failed to update folder: ' + (data.detail || 'Unknown error'), 'error');
                }
            } catch (error) {
                showStatus('Failed to update folder: ' + error.message, 'error');
            }
        }
        
        // Close dialog when clicking outside
        document.addEventListener('click', (e) => {
            const dialog = document.getElementById('folderDialog');
            if (dialog.classList.contains('active') && e.target === dialog) {
                hideFolderDialog();
            }
        });
        
        // Currently playing functionality
        let currentlyPlayingInterval = null;
        
        async function updateCurrentlyPlaying() {
            try {
                const response = await fetch('/api/currently-playing');
                const data = await response.json();
                const playingEl = document.getElementById('currentlyPlaying');
                
                if (!playingEl) return;
                
                if (data.playing && data.playing.length > 0) {
                    // Show first playing movie (or all if multiple)
                    const firstMovie = data.playing[0];
                    playingEl.className = 'currently-playing has-movie';
                    playingEl.textContent = firstMovie.name;
                    playingEl.onclick = () => navigateTo(`/movie/${encodeURIComponent(firstMovie.path)}`);
                } else {
                    playingEl.className = 'currently-playing';
                    playingEl.textContent = 'nothing playing';
                    playingEl.onclick = null;
                }
            } catch (error) {
                console.error('Error updating currently playing:', error);
            }
        }
        
        function startCurrentlyPlayingPolling() {
            // Update immediately
            updateCurrentlyPlaying();
            // Then poll every 3 seconds
            if (currentlyPlayingInterval) {
                clearInterval(currentlyPlayingInterval);
            }
            currentlyPlayingInterval = setInterval(updateCurrentlyPlaying, 3000);
        }
        
        function stopCurrentlyPlayingPolling() {
            if (currentlyPlayingInterval) {
                clearInterval(currentlyPlayingInterval);
                currentlyPlayingInterval = null;
            }
        }
        
        // History functions
        async function loadHistory() {
            const historyList = document.getElementById('historyList');
            if (!historyList) return;
            
            historyList.innerHTML = '<div class="loading">Loading history...</div>';
            
            try {
                const response = await fetch('/api/launch-history');
                const data = await response.json();
                
                if (!response.ok) {
                    historyList.innerHTML = '<div class="empty-state">Error loading history: ' + (data.detail || 'Unknown error') + '</div>';
                    return;
                }
                
                const launches = data.launches || [];
                
                if (launches.length === 0) {
                    historyList.innerHTML = '<div class="empty-state">No launch history yet</div>';
                    return;
                }
                
                let html = '';
                for (const launch of launches) {
                    const movie = launch.movie;
                    const timestamp = launch.timestamp;
                    
                    // Format timestamp with day of week
                    let formattedTime = 'Unknown time';
                    if (timestamp) {
                        try {
                            const date = new Date(timestamp);
                            const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                            const dayOfWeek = daysOfWeek[date.getDay()];
                            formattedTime = `${dayOfWeek}, ${date.toLocaleString()}`;
                        } catch (e) {
                            formattedTime = timestamp;
                        }
                    }
                    
                    // Create movie card HTML wrapped in history item
                    html += `
                        <div class="history-item">
                            <div class="history-timestamp">${escapeHtml(formattedTime)}</div>
                            <div class="history-movie-card">
                                ${createMovieCard(movie)}
                            </div>
                        </div>
                    `;
                }
                
                historyList.innerHTML = html;
            } catch (error) {
                historyList.innerHTML = '<div class="empty-state">Error loading history: ' + error.message + '</div>';
                console.error('History error:', error);
            }
        }
        
        // Name Cleaning Functions
        let cleaningPatternsData = null;
        
        async function loadCleaningPatterns() {
            const container = document.getElementById('cleaningPatternsContainer');
            const status = document.getElementById('cleaningStatus');
            
            container.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">Analyzing movie names...</div>';
            status.style.display = 'none';
            
            try {
                const response = await fetch('/api/cleaning-patterns');
                const data = await response.json();
                cleaningPatternsData = data;
                
                renderCleaningPatterns(data);
            } catch (error) {
                console.error('Error loading cleaning patterns:', error);
                container.innerHTML = `<div style="text-align: center; padding: 40px; color: #f44336;">Error loading patterns: ${error.message}</div>`;
            }
        }
        
        function renderCleaningPatterns(data) {
            const container = document.getElementById('cleaningPatternsContainer');
            const analysis = data.analysis;
            const current = data.current_patterns;
            
            let html = '';
            
            // Year patterns section
            html += `<div class="cleaning-section" style="margin-bottom: 30px;">
                <h2 style="margin-bottom: 15px;">Year Extraction</h2>
                <p style="color: #aaa; margin-bottom: 15px;">Years found in movie names (1900-2035). Years will be extracted and stored separately.</p>
                <label style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                    <input type="checkbox" id="yearPatternsEnabled" ${current.year_patterns ? 'checked' : ''} onchange="updateYearPatterns()">
                    <span>Extract and remove years from movie names</span>
                </label>
                <div style="background: #2a2a2a; padding: 15px; border-radius: 6px; max-height: 200px; overflow-y: auto;">
                    <div style="color: #999; font-size: 12px; margin-bottom: 10px;">Found ${analysis.years.length} unique years</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                        ${analysis.years.slice(0, 50).map(y => `<span style="background: #3a3a3a; padding: 4px 8px; border-radius: 4px; font-size: 12px;">${escapeHtml(y.pattern)} (${y.count})</span>`).join('')}
                    </div>
                </div>
            </div>`;
            
            // Bracket patterns section
            html += `<div class="cleaning-section" style="margin-bottom: 30px;">
                <h2 style="margin-bottom: 15px;">Bracket Patterns [anything]</h2>
                <p style="color: #aaa; margin-bottom: 15px;">Patterns found in square brackets. Select which ones to remove.</p>
                <div style="margin-bottom: 15px; padding: 10px; background: #3a3a3a; border-radius: 6px;">
                    <label style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                        <input type="checkbox" id="bracketAnything" class="bracket-special" data-pattern="[anything]" ${current.bracket_patterns.includes('[anything]') ? 'checked' : ''}>
                        <span><strong>Remove ALL bracket patterns</strong> (select this to remove everything in brackets)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="bracketAll" onchange="toggleAllBrackets(this.checked)">
                        <span>Select all individual bracket patterns below</span>
                    </label>
                </div>
                <div style="background: #2a2a2a; padding: 15px; border-radius: 6px; max-height: 400px; overflow-y: auto;">
                    ${analysis.bracket_patterns.map(p => {
                        const isApproved = current.bracket_patterns.includes(p.pattern) || current.bracket_patterns.includes('[anything]');
                        return `<div style="display: flex; align-items: center; gap: 10px; padding: 8px; border-bottom: 1px solid #3a3a3a;">
                            <input type="checkbox" class="bracket-checkbox" data-pattern="${escapeHtml(p.pattern)}" ${isApproved ? 'checked' : ''}>
                            <code style="flex: 1; color: #4a9eff;">${escapeHtml(p.pattern)}</code>
                            <span style="color: #999; font-size: 12px;">${p.count} occurrences</span>
                        </div>`;
                    }).join('')}
                    ${analysis.bracket_patterns.length === 0 ? '<div style="color: #666; text-align: center; padding: 20px;">No bracket patterns found</div>' : ''}
                </div>
            </div>`;
            
            // Parentheses patterns section
            html += `<div class="cleaning-section" style="margin-bottom: 30px;">
                <h2 style="margin-bottom: 15px;">Parentheses Patterns (anything)</h2>
                <p style="color: #aaa; margin-bottom: 15px;">Patterns found in parentheses. Select which ones to remove.</p>
                <div style="margin-bottom: 15px; padding: 10px; background: #3a3a3a; border-radius: 6px;">
                    <label style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                        <input type="checkbox" id="parenAnything" class="paren-special" data-pattern="(anything)" ${current.parentheses_patterns.includes('(anything)') ? 'checked' : ''}>
                        <span><strong>Remove ALL parentheses patterns</strong> (select this to remove everything in parentheses)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="parenAll" onchange="toggleAllParentheses(this.checked)">
                        <span>Select all individual parentheses patterns below</span>
                    </label>
                </div>
                <div style="background: #2a2a2a; padding: 15px; border-radius: 6px; max-height: 400px; overflow-y: auto;">
                    ${analysis.parentheses_patterns.map(p => {
                        const isApproved = current.parentheses_patterns.includes(p.pattern) || current.parentheses_patterns.includes('(anything)');
                        return `<div style="display: flex; align-items: center; gap: 10px; padding: 8px; border-bottom: 1px solid #3a3a3a;">
                            <input type="checkbox" class="paren-checkbox" data-pattern="${escapeHtml(p.pattern)}" ${isApproved ? 'checked' : ''}>
                            <code style="flex: 1; color: #4a9eff;">${escapeHtml(p.pattern)}</code>
                            <span style="color: #999; font-size: 12px;">${p.count} occurrences</span>
                        </div>`;
                    }).join('')}
                    ${analysis.parentheses_patterns.length === 0 ? '<div style="color: #666; text-align: center; padding: 20px;">No parentheses patterns found</div>' : ''}
                </div>
            </div>`;
            
            // Exact strings section
            html += `<div class="cleaning-section" style="margin-bottom: 30px;">
                <h2 style="margin-bottom: 15px;">Exact Strings</h2>
                <p style="color: #aaa; margin-bottom: 15px;">Common clutter strings (resolution, codec, etc.). Select which ones to remove.</p>
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="exactAll" onchange="toggleAllExact(this.checked)">
                        <span>Select all exact strings</span>
                    </label>
                </div>
                <div style="background: #2a2a2a; padding: 15px; border-radius: 6px; max-height: 400px; overflow-y: auto;">
                    ${analysis.exact_strings.map(p => {
                        const isApproved = current.exact_strings.includes(p.pattern);
                        return `<div style="display: flex; align-items: center; gap: 10px; padding: 8px; border-bottom: 1px solid #3a3a3a;">
                            <input type="checkbox" class="exact-checkbox" data-pattern="${escapeHtml(p.pattern)}" ${isApproved ? 'checked' : ''}>
                            <code style="flex: 1; color: #4a9eff;">${escapeHtml(p.pattern)}</code>
                            <span style="color: #999; font-size: 12px;">${p.count} occurrences</span>
                        </div>`;
                    }).join('')}
                    ${analysis.exact_strings.length === 0 ? '<div style="color: #666; text-align: center; padding: 20px;">No exact strings found</div>' : ''}
                </div>
            </div>`;
            
            html += `<div style="margin-top: 30px; padding: 20px; background: #2a2a2a; border-radius: 6px;">
                <p style="color: #aaa; margin-bottom: 10px;"><strong>Total movies analyzed:</strong> ${analysis.total_movies}</p>
                <p style="color: #999; font-size: 12px;">After saving patterns, re-index your movies to apply the cleaning rules.</p>
            </div>`;
            
            container.innerHTML = html;
        }
        
        function toggleAllBrackets(checked) {
            document.querySelectorAll('.bracket-checkbox').forEach(cb => cb.checked = checked);
        }
        
        function toggleAllParentheses(checked) {
            document.querySelectorAll('.paren-checkbox').forEach(cb => cb.checked = checked);
        }
        
        function toggleAllExact(checked) {
            document.querySelectorAll('.exact-checkbox').forEach(cb => cb.checked = checked);
        }
        
        function updateYearPatterns() {
            // This is handled in saveCleaningPatterns
        }
        
        async function saveCleaningPatterns() {
            if (!cleaningPatternsData) {
                alert('Please load patterns first');
                return;
            }
            
            const status = document.getElementById('cleaningStatus');
            status.style.display = 'block';
            status.style.background = '#2a2a2a';
            status.style.color = '#aaa';
            status.textContent = 'Saving patterns...';
            
            try {
                // Collect approved patterns
                const bracketAnything = document.getElementById('bracketAnything')?.checked;
                const bracketPatterns = bracketAnything 
                    ? ['[anything]']
                    : Array.from(document.querySelectorAll('.bracket-checkbox:checked')).map(cb => cb.dataset.pattern);
                
                const parenAnything = document.getElementById('parenAnything')?.checked;
                const parenPatterns = parenAnything
                    ? ['(anything)']
                    : Array.from(document.querySelectorAll('.paren-checkbox:checked')).map(cb => cb.dataset.pattern);
                
                const exactStrings = Array.from(document.querySelectorAll('.exact-checkbox:checked')).map(cb => cb.dataset.pattern);
                const yearPatterns = document.getElementById('yearPatternsEnabled').checked;
                
                const data = {
                    bracket_patterns: bracketPatterns,
                    parentheses_patterns: parenPatterns,
                    exact_strings: exactStrings,
                    year_patterns: yearPatterns
                };
                
                const response = await fetch('/api/cleaning-patterns', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                
                if (response.ok) {
                    status.style.background = '#4caf50';
                    status.style.color = '#fff';
                    status.textContent = 'Patterns saved successfully! Re-index your movies to apply the cleaning rules.';
                    
                    // Update current patterns in data
                    cleaningPatternsData.current_patterns = {
                        bracket_patterns: bracketPatterns,
                        parentheses_patterns: parenPatterns,
                        exact_strings: exactStrings,
                        year_patterns: yearPatterns
                    };
                } else {
                    throw new Error('Failed to save patterns');
                }
            } catch (error) {
                console.error('Error saving patterns:', error);
                status.style.background = '#f44336';
                status.style.color = '#fff';
                status.textContent = `Error saving patterns: ${error.message}`;
            }
        }
        
        // Load stats and folder path on page load
        loadStats();
        loadCurrentFolder();
        startCurrentlyPlayingPolling();
    </script>
</body>
</html>
