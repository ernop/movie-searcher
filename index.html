<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Movie Searcher</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            margin-bottom: 20px;
            color: #fff;
            font-weight: 300;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .btn {
            background: #4a9eff;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0s;
        }
        
        .btn:hover {
            background: #5aaeff;
        }
        
        .btn-secondary {
            background: #3a3a3a;
        }
        
        .btn-secondary:hover {
            background: #4a4a4a;
        }
        
        .btn-success {
            background: #4caf50;
        }
        
        .btn-success:hover {
            background: #5cbf60;
        }
        
        .btn:disabled {
            background: #2a2a2a;
            color: #666;
            cursor: not-allowed;
        }
        
        .search-container {
            position: relative;
            margin-bottom: 25px;
        }
        
        #searchInput {
            width: 100%;
            padding: 15px 20px;
            font-size: 18px;
            background: #2a2a2a;
            border: 2px solid #3a3a3a;
            border-radius: 8px;
            color: #fff;
            outline: none;
            transition: border-color 0s;
        }
        
        #searchInput:focus {
            border-color: #4a9eff;
        }
        
        #searchInput::placeholder {
            color: #666;
        }
        
        .clear-search-btn {
            display: inline-block;
            margin-top: 6px;
            background: #3a3a3a;
            color: #e0e0e0;
            border: 1px solid #4a4a4a;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0s;
        }
        
        .clear-search-btn:hover {
            background: #4a4a4a;
            border-color: #4a9eff;
        }
        
        .clear-search-btn:active {
            background: #2a2a2a;
        }
        
        .filter-options {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-top: 0;
            margin-bottom: 25px;
            position: relative;
            flex-wrap: wrap;
        }
        
        .language-filter-group {
            margin-left: 0;
        }
        
        .btn-group {
            display: inline-flex;
            position: relative;
            vertical-align: middle;
        }
        
        .btn-group-toggle .btn {
            border: 1px solid #4a4a4a !important;
            background: #3a3a3a !important;
            color: #e0e0e0 !important;
            padding: 8px 16px !important;
            font-size: 14px;
            cursor: pointer;
            transition: all 0s;
            border-radius: 0 !important;
            margin: 0;
            outline: none;
        }
        
        .btn-group-toggle .btn:first-child {
            border-top-left-radius: 6px !important;
            border-bottom-left-radius: 6px !important;
        }
        
        .btn-group-toggle .btn:last-child {
            border-top-right-radius: 6px !important;
            border-bottom-right-radius: 6px !important;
        }
        
        .btn-group-toggle .btn:not(:first-child) {
            border-left: none !important;
        }
        
        .btn-group-toggle .btn:hover {
            background: #4a4a4a !important;
            color: #fff !important;
        }
        
        .btn-group-toggle .btn.active {
            background: #4a9eff !important;
            border-color: #4a9eff !important;
            color: #fff !important;
            z-index: 1;
        }
        
        .btn-group-toggle .btn.active:hover {
            background: #5aaeff !important;
            border-color: #5aaeff !important;
        }
        
        .filter-options label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .filter-options input[type="checkbox"],
        .filter-options input[type="radio"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .autocomplete {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        
        .autocomplete-item {
            padding: 12px 20px;
            cursor: pointer;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0s;
        }
        
        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background: #3a3a3a;
        }
        
        .autocomplete-item:last-child {
            border-bottom: none;
        }
        
        .movie-name {
            font-weight: 500;
            flex: 1;
        }
        
        .movie-meta {
            font-size: 12px;
            color: #999;
            margin-left: 15px;
        }
        
        .results {
            margin-top: 20px;
        }
        
        .result-item {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            padding: 15px 20px;
            margin-bottom: 10px;
            transition: background 0s;
        }
        
        .result-item:hover {
            background: #333;
        }
        
        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }
        
        .result-info {
            flex: 1;
        }
        
        .result-name {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 5px;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .watched-badge {
            background: #4caf50;
            color: #fff;
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 12px;
        }
        
        .result-path {
            font-size: 12px;
            color: #999;
            margin-bottom: 5px;
            word-break: break-all;
        }
        
        .result-meta {
            font-size: 12px;
            color: #777;
        }
        
        .external-links {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .external-link {
            color: #4a9eff;
            text-decoration: none;
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            transition: all 0s;
        }
        
        .external-link:hover {
            background: #2a2a2a;
            border-color: #4a9eff;
            color: #5aaeff;
        }
        
        .result-actions {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .launch-btn {
            background: #4a9eff;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0s;
        }
        
        .launch-btn:hover {
            background: #5aaeff;
        }
        
        .watched-btn {
            background: #3a3a3a;
            color: #fff;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0s;
        }
        
        .watched-btn:hover {
            background: #4a4a4a;
        }
        
        .watched-btn.watched {
            background: #4caf50;
        }
        
        .watched-btn.watched:hover {
            background: #5cbf60;
        }
        
        .subtitle-select {
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #3a3a3a;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .subtitle-select:focus {
            outline: none;
            border-color: #4a9eff;
        }
        
        .stats {
            margin-top: 30px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 8px;
            font-size: 14px;
            color: #999;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }
        
        .watched-section {
            margin-top: 30px;
            display: none;
        }
        
        .watched-section.active {
            display: block;
        }
        
        .section-title {
            font-size: 20px;
            font-weight: 500;
            margin-bottom: 15px;
            color: #fff;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #999;
        }
        
        .status-message {
            padding: 10px 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 14px;
        }
        
        .status-message.success {
            background: #1e4620;
            color: #4caf50;
            border: 1px solid #4caf50;
        }
        
        .status-message.error {
            background: #4a1e1e;
            color: #f44336;
            border: 1px solid #f44336;
        }
        
        .status-message.info {
            background: #1e3a4a;
            color: #4a9eff;
            border: 1px solid #4a9eff;
        }
        
        .folder-info {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: #2a2a2a;
            border-radius: 6px;
            font-size: 13px;
            color: #999;
            flex: 1;
            min-width: 200px;
        }
        
        .folder-path {
            color: #e0e0e0;
            word-break: break-all;
        }
        
        .folder-input {
            display: none;
        }
        
        .folder-dialog {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            border: 2px solid #3a3a3a;
            border-radius: 8px;
            padding: 20px;
            z-index: 2000;
            min-width: 400px;
            max-width: 600px;
        }
        
        .folder-dialog.active {
            display: block;
        }
        
        .folder-dialog h3 {
            margin-bottom: 15px;
            color: #fff;
        }
        
        .folder-dialog input[type="text"] {
            width: 100%;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            margin-bottom: 15px;
        }
        
        .folder-dialog .dialog-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .progress-container {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 8px;
            border: 1px solid #3a3a3a;
        }
        
        .progress-container.active {
            display: block;
        }
        
        .progress-bar-container {
            width: 100%;
            height: 24px;
            background: #1a1a1a;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 10px;
            border: 1px solid #3a3a3a;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4a9eff, #5aaeff);
            transition: width 0s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 12px;
            font-weight: 500;
        }
        
        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: #999;
            margin-bottom: 5px;
        }
        
        .progress-file {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            word-break: break-all;
        }
        
        .scan-log-window {
            margin-top: 15px;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.25;
            padding: 10px;
        }
        
        .scan-log-window::-webkit-scrollbar {
            width: 8px;
        }
        
        .scan-log-window::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        .scan-log-window::-webkit-scrollbar-thumb {
            background: #4a4a4a;
            border-radius: 4px;
        }
        
        .scan-log-window::-webkit-scrollbar-thumb:hover {
            background: #5a5a5a;
        }
        
        .log-entry {
            margin-bottom: 1px;
            padding: 0;
            word-wrap: break-word;
        }
        
        .log-entry .log-timestamp {
            color: #666;
            margin-right: 8px;
        }
        
        .log-entry.info {
            color: #e0e0e0;
        }
        
        .log-entry.success {
            color: #4caf50;
        }
        
        .log-entry.warning {
            color: #ff9800;
        }
        
        .log-entry.error {
            color: #f44336;
        }
        
        .log-entry .log-level {
            display: inline-block;
            width: 60px;
            font-weight: 500;
            margin-right: 8px;
        }
        
        .media-gallery {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            max-width: 100%;
        }
        
        .media-item {
            position: relative;
            cursor: pointer;
            border-radius: 6px;
            overflow: hidden;
            border: 2px solid #3a3a3a;
            transition: border-color 0s, transform 0s;
            background: #1a1a1a;
        }
        
        .media-item:hover {
            border-color: #4a9eff;
            transform: scale(1.05);
            z-index: 10;
        }
        
        .media-item img {
            display: block;
            width: 200px;
            height: 112px;
            object-fit: cover;
            background: #1a1a1a;
        }
        
        .media-item.large {
            width: 300px;
            height: 169px;
        }
        
        .media-item.large img {
            width: 300px;
            height: 169px;
        }
        
        .media-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            color: #fff;
            padding: 5px 8px;
            font-size: 11px;
            text-align: center;
        }
        
        .media-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 3000;
            cursor: pointer;
            align-items: center;
            justify-content: center;
        }
        
        .media-overlay.active {
            display: flex;
        }
        
        .media-overlay img {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
        }
        
        .media-overlay-close {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #fff;
            font-size: 30px;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.5);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0s;
        }
        
        .media-overlay-close:hover {
            background: rgba(0, 0, 0, 0.8);
        }
        
        .star-rating {
            display: inline-flex;
            gap: 1px;
            align-items: center;
            cursor: pointer;
            user-select: none;
            margin-right: 8px;
        }
        
        .star {
            font-size: 18px;
            color: #666;
            transition: color 0s, transform 0s;
            position: relative;
            width: 18px;
            height: 18px;
            display: inline-block;
        }
        
        .star:hover {
            transform: scale(1.2);
        }
        
        .star.active {
            color: #ffd700;
        }
        
        .star.half {
            position: relative;
        }
        
        .star.half::before {
            content: '★';
            position: absolute;
            left: 0;
            top: 0;
            width: 50%;
            overflow: hidden;
            color: #ffd700;
        }
        
        .star-rating:hover .star {
            color: #ffd700;
        }
        
        .star-rating .star.active ~ .star {
            color: #666;
        }
        
        .star-rating .star.half ~ .star {
            color: #666;
        }
        
        .explore-section {
            margin-top: 30px;
            display: none;
        }
        
        .explore-section.active {
            display: block;
        }
        
        .explore-filters {
            display: flex;
            gap: 0;
            align-items: center;
            margin-top: 0;
            margin-bottom: 25px;
            position: relative;
        }
        
        .letter-nav {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 8px;
            border: 1px solid #3a3a3a;
        }
        
        .letter-btn {
            background: #3a3a3a;
            color: #e0e0e0;
            border: 1px solid #4a4a4a;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0s;
            min-width: 40px;
            text-align: center;
        }
        
        .letter-btn:hover {
            background: #4a4a4a;
            border-color: #4a9eff;
        }
        
        .letter-btn.active {
            background: #4a9eff;
            border-color: #4a9eff;
            color: #fff;
        }
        
        .letter-btn:disabled {
            background: #1a1a1a;
            color: #555;
            border-color: #2a2a2a;
            cursor: not-allowed;
        }
        
        .decade-nav {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 8px;
            border: 1px solid #3a3a3a;
        }
        
        .decade-btn {
            background: #3a3a3a;
            color: #e0e0e0;
            border: 1px solid #4a4a4a;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0s;
            min-width: 60px;
            text-align: center;
        }
        
        .decade-btn:hover {
            background: #4a4a4a;
            border-color: #4a9eff;
        }
        
        .decade-btn.active {
            background: #4a9eff;
            border-color: #4a9eff;
            color: #fff;
        }
        
        .decade-btn:disabled {
            background: #1a1a1a;
            color: #555;
            border-color: #2a2a2a;
            cursor: not-allowed;
        }
        
        .year-filter-container {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .year-input-wrapper {
            position: relative;
            flex: 1;
            min-width: 200px;
            max-width: 300px;
        }
        
        .year-input {
            width: 100%;
            padding: 8px 12px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
            transition: border-color 0.2s;
        }
        
        .year-input:focus {
            outline: none;
            border-color: #4a9eff;
        }
        
        .year-input::placeholder {
            color: #666;
        }
        
        .year-autocomplete {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 4px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        
        .year-autocomplete-item {
            padding: 8px 12px;
            cursor: pointer;
            color: #e0e0e0;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        .year-autocomplete-item:hover {
            background: #3a3a3a;
        }
        
        .year-autocomplete-item.active {
            background: #4a9eff;
            color: #fff;
        }
        
        .year-chip-container {
            display: flex;
            gap: 4px;
            align-items: center;
        }
        
        .year-nav-btn {
            background: #3a3a3a;
            color: #e0e0e0;
            border: 1px solid #4a4a4a;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            min-width: 32px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .year-nav-btn:hover:not(:disabled) {
            background: #4a4a4a;
            border-color: #4a9eff;
        }
        
        .year-nav-btn:disabled {
            background: #1a1a1a;
            color: #555;
            border-color: #2a2a2a;
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .year-chip {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: #4a9eff;
            color: #fff;
            border-radius: 16px;
            font-size: 13px;
        }
        
        .year-chip-close {
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        
        .year-chip-close:hover {
            opacity: 1;
        }
        
        .movie-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .movie-card {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            overflow: hidden;
            transition: background-color 0s, border-color 0s;
            cursor: pointer;
            max-width: 320px;
            width: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .movie-card:hover {
            background: #333333;
            border-color: #4a9eff;
        }
        
        .movie-card-image {
            width: 100%;
            aspect-ratio: 16 / 9;
            min-height: 180px;
            max-height: 280px;
            background: #1a1a1a;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 14px;
            position: relative;
            overflow: hidden;
        }
        
        .movie-card-image img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            object-position: center;
        }
        
        .movie-card-body {
            padding: 15px 15px 5px 15px;
        }
        
        .movie-card-title {
            font-size: 14px;
            font-weight: 500;
            color: #fff;
            margin-bottom: 10px;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        .movie-card-actions {
            display: flex;
            gap: 8px;
        }
        
        .movie-card-launch {
            flex: 1;
            background: #4a9eff;
            color: #fff;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0s;
        }
        
        .movie-card-launch:hover {
            background: #5aaeff;
        }
        
        .pagination {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        .pagination-btn {
            background: #3a3a3a;
            color: #e0e0e0;
            border: 1px solid #4a4a4a;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0s;
        }
        
        .pagination-btn:hover:not(:disabled) {
            background: #4a4a4a;
            border-color: #4a9eff;
        }
        
        .pagination-btn:disabled {
            background: #1a1a1a;
            color: #555;
            border-color: #2a2a2a;
            cursor: not-allowed;
        }
        
        .pagination-btn.active {
            background: #4a9eff;
            border-color: #4a9eff;
            color: #fff;
        }
        
        .pagination-info {
            color: #999;
            font-size: 14px;
            margin: 0 10px;
        }
        
        .page {
            display: none;
        }
        
        .page.active {
            display: block;
        }
        
        .nav-link {
            background: #3a3a3a;
            color: #e0e0e0;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0s;
            text-decoration: none;
            display: inline-block;
        }
        
        .nav-link:hover {
            background: #4a4a4a;
        }
        
        .nav-link.active {
            background: #4a9eff;
            color: #fff;
        }
        
        .movie-card-meta {
            font-size: 12px;
            color: #999;
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .launch-status-checkbox {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid #4a9eff;
            background: transparent;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .launch-status-checkbox.launched {
            background: #4a9eff;
            border-color: #4a9eff;
        }
        
        .launch-status-checkbox.launched::after {
            content: '✓';
            color: #fff;
            font-size: 12px;
            font-weight: bold;
        }
        
        .movie-card-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        .movie-card-btn {
            background: transparent;
            color: #e0e0e0;
            border: none;
            padding: 0.6px 1px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0s;
            display: flex;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
        }
        
        .movie-card-btn:hover {
            background: #3a3a3a;
        }
        
        .movie-card-btn .watched-checkbox {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .movie-card-btn .watched-checkbox.unset {
            background: #2196f3;
        }
        
        .movie-card-btn .watched-checkbox.watched {
            background: #4caf50;
        }
        
        .movie-card-btn .watched-checkbox.unwatched {
            background: #f44336;
        }
        
        .movie-card-btn .watched-checkbox::after {
            content: '✓';
            color: #fff;
            font-size: 9px;
            font-weight: bold;
        }
        
        .movie-card-btn.rating {
            background: #ffd700;
            color: #000;
        }
        
        .movie-card-buttons .star-rating {
            flex: 1;
            margin-right: 0;
            justify-content: center;
            padding: 4px 0;
        }
        
        .movie-card-buttons .star-rating .star {
            font-size: 14px;
            width: 14px;
            height: 14px;
        }
        
        .movie-details-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .movie-details-header {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .movie-details-poster {
            flex-shrink: 0;
            width: 300px;
            height: 450px;
            background: #1a1a1a;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .movie-details-poster img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .movie-details-info {
            flex: 1;
        }
        
        .movie-details-title {
            font-size: 32px;
            font-weight: 500;
            color: #fff;
            margin-bottom: 10px;
        }
        
        .movie-details-meta {
            font-size: 14px;
            color: #999;
            margin-bottom: 20px;
        }
        
        .year-link {
            cursor: pointer;
            color: #4a9eff;
            text-decoration: underline;
            transition: color 0.2s;
        }
        
        .year-link:hover {
            color: #6bb3ff;
        }
        
        .movie-details-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .back-button {
            background: #3a3a3a;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0s;
            margin-bottom: 20px;
        }
        
        .back-button:hover {
            background: #4a4a4a;
        }
        
        .setup-section {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .setup-section h3 {
            color: #fff;
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 15px;
        }
        
        .setup-section p {
            color: #999;
            font-size: 14px;
            margin-bottom: 15px;
            line-height: 1.5;
        }
        
        .setup-option {
            margin-bottom: 20px;
        }
        
        .setup-option label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-size: 14px;
            color: #e0e0e0;
        }
        
        .setup-option input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .setup-option-description {
            font-size: 12px;
            color: #777;
            margin-top: 5px;
            margin-left: 28px;
        }
        
        .currently-playing {
            font-size: 20px;
            color: #999;
            font-style: italic;
            background: rgba(255, 255, 255, 0.05);
            padding: 8px 12px;
            border-radius: 6px;
            transition: all 0.2s;
        }
        
        .currently-playing .prefix {
            color: #fff;
            margin-right: 6px;
        }
        
        .currently-playing .name {
            font-size: 120%;
        }
        
        .currently-playing.has-movie {
            font-style: normal;
            color: #4a9eff;
            cursor: pointer;
            text-decoration: none;
            background: rgba(74, 158, 255, 0.15);
            transition: all 0.2s;
        }
        
        .currently-playing.has-movie:hover {
            color: #5aaeff;
            text-decoration: underline;
            background: rgba(74, 158, 255, 0.25);
        }
        
        .history-list {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, max-content));
            gap: 20px;
        }
        
        .history-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: stretch;
            background: transparent;
            border: none;
            padding: 0;
        }
        
        .history-item:hover {
            background: transparent;
        }
        
        .history-timestamp {
            font-size: 13px;
            color: #999;
            width: 100%;
        }
        
        .history-movie-card {
            width: 100%;
        }
    </style>
    <script src="star-rating.js"></script>
</head>
<body>
    <div id="app">
        <div class="controls" id="globalControls">
            <div style="display: flex; gap: 10px; align-items: center;">
                <a href="#/home" class="nav-link" id="navHome">Home</a>
                <a href="#/explore" class="nav-link" id="navExplore">Explore</a>
                <a href="#/history" class="nav-link" id="navHistory">History</a>
            </div>
            <div style="margin-left: auto; display: flex; gap: 10px; align-items: center;">
                <div id="statusMessage"></div>
                <div id="currentlyPlaying" class="currently-playing">nothing playing</div>
                <a href="#/setup" class="nav-link" id="navSetup">Setup</a>
            </div>
        </div>
        
        <!-- Home Page -->
        <div class="page active" id="pageHome">
            <h1>Movie Searcher</h1>
            
            <div class="search-container">
                <input type="text" id="searchInput" placeholder="Search movies..." autocomplete="off">
                <div class="autocomplete" id="autocomplete"></div>
                <button class="clear-search-btn" id="clearSearchBtn" onclick="clearSearch()" style="display: none;">× Clear</button>
            </div>
            
             <div class="filter-options">
                 <div class="btn-group btn-group-toggle" role="group">
                     <button type="button" class="btn active" data-filter="all" onclick="setWatchFilter('all', this)">All</button>
                     <button type="button" class="btn" data-filter="watched" onclick="setWatchFilter('watched', this)">Watched only</button>
                     <button type="button" class="btn" data-filter="unwatched" onclick="setWatchFilter('unwatched', this)">Unwatched only</button>
                 </div>
                 <!-- Language filter moved to Explore -->
             </div>
            
            <div class="results" id="results"></div>
            
            <div class="watched-section" id="watchedSection">
                <div class="section-title">Watched Movies</div>
                <button class="btn btn-secondary" id="viewWatchedBtn" onclick="toggleWatchedView()">View Watched</button>
                <div id="watchedList"></div>
            </div>
            
            <div class="stats" id="stats"></div>
        </div>
        
        <!-- Explore Page -->
        <div class="page" id="pageExplore">
            <h1>Explore Movies</h1>
            
            <div class="explore-filters">
                <div class="btn-group btn-group-toggle" role="group">
                    <button type="button" class="btn active" data-filter="all" onclick="setExploreWatchFilter('all', this)">All</button>
                    <button type="button" class="btn" data-filter="watched" onclick="setExploreWatchFilter('watched', this)">Watched only</button>
                    <button type="button" class="btn" data-filter="unwatched" onclick="setExploreWatchFilter('unwatched', this)">Unwatched only</button>
                </div>
                <div style="margin-left:16px;padding-left:16px;border-left: 2px solid #e0e0e0;">
                    <div class="btn-group btn-group-toggle language-filter-group" role="group" id="exploreLanguageFilterGroup" style="display:inline-flex;flex-wrap:wrap;gap:0;align-items:center;">
                        <!-- Audio language buttons will be populated by JavaScript -->
                    </div>
                </div>
            </div>
            
            <div class="letter-nav" id="letterNav"></div>
            
            <div class="decade-nav" id="decadeNav"></div>
            
            <div class="year-filter-container" id="yearFilterContainer">
                <div class="year-input-wrapper">
                    <input type="text" id="yearInput" placeholder="Filter by year..." autocomplete="off" class="year-input">
                    <div class="year-autocomplete" id="yearAutocomplete"></div>
                </div>
                <div class="year-chip-container" id="yearChipContainer"></div>
            </div>
            
            <div class="movie-grid" id="movieGrid"></div>
            
            <div class="pagination" id="explorePagination"></div>
        </div>
        
        <!-- Movie Details Page -->
        <div class="page" id="pageMovieDetails">
            <button class="back-button" onclick="navigateTo('/home')">← Back</button>
            <div class="movie-details-container" id="movieDetailsContainer">
                <div class="loading">Loading movie details...</div>
            </div>
        </div>
        
        <!-- History Page -->
        <div class="page" id="pageHistory">
            <h1>Launch History</h1>
            <div id="historyList" class="history-list"></div>
        </div>
        
        <!-- Setup Page -->
        <div class="page" id="pageSetup">
            <h1>Setup</h1>
            
            <div class="setup-section">
                <h3>Movies Folder</h3>
                <p>Configure the folder where your movies are stored. The application will scan this folder to index all video files.</p>
                <div class="folder-info" style="margin-bottom: 15px;">
                    <span>Current folder:</span>
                    <span class="folder-path" id="setupCurrentFolder">Loading...</span>
                </div>
                <button class="btn" id="setupChangeFolderBtn" onclick="showFolderDialog()">Change Movies Folder</button>
            </div>
            
            <div class="setup-section">
                <h3>Scan Movies</h3>
                <p>Scan your movies folder to index all video files. This will update the database with any new or changed files.</p>
                <button class="btn" id="setupScanBtn" onclick="scanFolder()">Scan Movies Folder</button>
                <div class="progress-container" id="setupProgressContainer" style="margin-top: 15px;">
                    <div class="progress-info">
                        <span id="setupProgressStatus">Preparing scan...</span>
                        <span id="setupProgressCount">0 / 0</span>
                    </div>
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="setupProgressBar" style="width: 0%">0%</div>
                    </div>
                    <div class="progress-file" id="setupProgressFile"></div>
                    <div class="scan-log-window" id="setupScanLogWindow" style="display: none;"></div>
                </div>
            </div>
            
            <div class="setup-section">
                <h3>VLC Settings</h3>
                <p>Configure how VLC media player behaves when launching movies.</p>
                <div class="setup-option">
                    <label>
                        <input type="checkbox" id="setupCloseExistingVlc" checked>
                        Close existing VLC windows when launching a new movie
                    </label>
                    <div class="setup-option-description">
                        When enabled, all existing VLC windows will be closed before launching a new movie. When disabled, new movies will open in addition to any existing VLC windows.
                    </div>
                </div>
            </div>
            
            <div class="setup-section">
                <h3>Name Cleaning</h3>
                <p>Re-apply name cleaning rules to all movies in the database.</p>
                <button class="btn" onclick="recleanAllNames()">Re-clean All Movie Names</button>
                <div id="recleanStatus" style="margin-top: 10px; padding: 10px; background: #2a2a2a; border-radius: 6px; display: none;"></div>
            </div>
            
            <div class="setup-section">
                <h3>Statistics</h3>
                <div id="setupStats"></div>
            </div>
        </div>
    
    <div class="folder-dialog" id="folderDialog">
        <h3>Select Movies Folder</h3>
        <p style="margin-bottom: 10px; color: #999; font-size: 13px;">Enter the full path to your movies folder:</p>
        <input type="text" id="folderPathInput" placeholder="C:\Movies or D:\Movies\MyCollection" style="margin-bottom: 15px;" autofocus>
        <p style="margin-bottom: 15px; color: #777; font-size: 12px;">You can use forward slashes (/) or backslashes (\) - they will be converted automatically.</p>
        <div class="dialog-buttons">
            <button class="btn btn-secondary" onclick="hideFolderDialog()">Cancel</button>
            <button class="btn btn-success" onclick="saveFolderPath()">Save</button>
        </div>
    </div>
    
    <div class="media-overlay" id="mediaOverlay" onclick="closeMediaOverlay()">
        <div class="media-overlay-close" onclick="event.stopPropagation(); closeMediaOverlay();">×</div>
        <img id="mediaOverlayImage" onclick="event.stopPropagation();" alt="Full size image">
    </div>
    
    <script>
        // Routing
        function getRoute() {
            const hash = window.location.hash || '#/home';
            return hash.substring(1); // Remove #
        }
        
        function navigateTo(route) {
            window.location.hash = route;
            handleRoute();
        }
        
        function handleRoute() {
            // Hash-first routing
            const route = getRoute();

            const pages = document.querySelectorAll('.page');
            pages.forEach(page => page.classList.remove('active'));
            
            // Update nav links
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + route) {
                    link.classList.add('active');
                }
            });
            
            const pageHome = document.getElementById('pageHome');
            const pageExplore = document.getElementById('pageExplore');
            const pageSetup = document.getElementById('pageSetup');
            const pageMovieDetails = document.getElementById('pageMovieDetails');
            const pageHistory = document.getElementById('pageHistory');

            // Detail routes (hash-based)
            if (route.startsWith('/movie/')) {
                const parts = route.split('/').filter(Boolean); // ["movie", "{id}", "{slug?}"]
                if (parts.length >= 2) {
                    const movieId = parseInt(parts[1], 10);
                    if (pageMovieDetails && !Number.isNaN(movieId)) {
                        pageMovieDetails.classList.add('active');
                        loadMovieDetailsById(movieId);
                        return;
                    }
                }
            }
            
            if (route === '/home' || route === '/') {
                 if (pageHome) pageHome.classList.add('active');
                 updateClearButtonVisibility();
             } else if (route === '/explore') {
                 if (pageExplore) {
                     pageExplore.classList.add('active');
                     exploreViewActive = true;
                     loadExploreMovies();
                 }
             } else if (route === '/history') {
                 if (pageHistory) {
                     pageHistory.classList.add('active');
                     loadHistory();
                 }
             } else if (route === '/setup') {
                 if (pageSetup) {
                     pageSetup.classList.add('active');
                     loadSetupPage();
                 }
            } else {
                 navigateTo('/home');
             }
        }
        
        window.addEventListener('hashchange', handleRoute);
        window.addEventListener('popstate', handleRoute);
        window.addEventListener('load', handleRoute);
        window.addEventListener('load', startCurrentlyPlayingPolling);

        // Movie Card Component
        function createMovieCard(movie) {
            const imageUrl = movie.screenshot_id
                ? `/api/screenshot/${movie.screenshot_id}`
                : (movie.image ? `/api/image?image_path=${encodeURIComponent(movie.image)}` : '');
            // Use watch_status if available, fallback to watched boolean for backward compatibility
            const watchStatus = movie.watch_status !== undefined ? movie.watch_status : (movie.watched ? true : null);
            const watchedClass = watchStatus === true ? 'watched' : '';
            const fileSize = movie.size ? formatSize(movie.size) : '';
            const year = movie.year ? movie.year : '';
            const length = movie.length ? formatMinutes(movie.length) : '';
            const hasLaunched = movie.has_launched || false;
            
            // Determine checkbox class based on watch_status
            let checkboxClass = 'unset';
            if (watchStatus === true) {
                checkboxClass = 'watched';
            } else if (watchStatus === false) {
                checkboxClass = 'unwatched';
            }
            
            // Prefer hash-based ID route if we have an id
            const slug = (movie.name || '').toString()
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-+|-+$/g, '');
            const cardClick = `openMovieHash(${movie.id}, '${encodeURIComponent(slug)}')`;

            return `
                <div class="movie-card ${watchedClass}" data-movie-id="${movie.id || ''}" onclick="${cardClick}">
                    <div class="movie-card-image">
                        ${imageUrl ? `<img src="${imageUrl}" alt="${escapeHtml(movie.name)}" loading="lazy" onerror="this.parentElement.innerHTML='No Image'">` : 'No Image'}
                    </div>
                    <div class="movie-card-body">
                        <div class="movie-card-title">${escapeHtml(movie.name)}</div>
                        <div class="movie-card-meta">
                            ${year ? `<span class="year-link" onclick="event.stopPropagation(); navigateToExploreWithYear(${year}, ${movie.id || 'null'});" title="Filter by ${year}">${year}</span>` : ''}
                            ${length ? `<span>${length}</span>` : ''}
                            ${fileSize ? `<span>${fileSize}</span>` : ''}
                            ${hasLaunched ? '<div class="launch-status-checkbox launched" onclick="event.stopPropagation();"></div>' : ''}
                        </div>
                        <div class="movie-card-buttons">
                            <button class="movie-card-btn" onclick="event.stopPropagation(); toggleWatched('${escapeJsString(movie.path)}', ${watchStatus === null ? 'null' : watchStatus})">
                                <span class="watched-checkbox ${checkboxClass}"></span>watched
                            </button>
                            ${renderStarRating(movie.path, watchStatus === true, movie.rating || null)}
                            <button class="movie-card-launch" onclick="event.stopPropagation(); launchMovie('${escapeJsString(movie.path)}')">▶</button>
                        </div>
                    </div>
                </div>
            `;
        }

        // Open detail page using hash-based SPA route
        function openMovieHash(id, slug) {
            const safeSlug = (slug || '').toString();
            navigateTo(`/movie/${id}/${safeSlug}`);
        }
        
        let selectedIndex = -1;
        let currentResults = [];
        let watchedViewActive = false;
        let exploreViewActive = false;
        let currentSubtitles = {};
        // Search pagination state for infinite scroll
        let searchPage = {
            query: '',
            filterType: 'all',
            language: 'all',
            offset: 0,
            limit: 50,
            total: 0,
            loading: false,
            done: false,
            requestId: -1,
            observer: null
        };
        // Explore page state - only for tracking current page, not for building requests
        let currentExplorePage = 1;
        const EXPLORE_PER_PAGE = 15;
        // Request sequencing to handle out-of-order AJAX responses
        let searchRequestCounter = 0;
        let lastDisplayedRequestId = -1;
        let searchAbortController = null;
        let searchDebounceTimer = null;
        let currentResultsAreLite = true;
        
        const searchInput = document.getElementById('searchInput');
        const autocomplete = document.getElementById('autocomplete');
        const results = document.getElementById('results');
        const stats = document.getElementById('stats');
        const viewWatchedBtn = document.getElementById('viewWatchedBtn');
        const watchedSection = document.getElementById('watchedSection');
        const watchedList = document.getElementById('watchedList');
        function getWatchFilter() {
            // Get watched filter from the first button group (not language filter)
            const watchedGroup = document.querySelector('.filter-options .btn-group-toggle:not(.language-filter-group)');
            if (watchedGroup) {
                const activeBtn = watchedGroup.querySelector('.btn.active');
                if (activeBtn) {
                    return activeBtn.getAttribute('data-filter') || 'all';
                }
            }
            return 'all';
        }
        
        // Language filter now on Explore only
        function getExploreLanguageFilter() {
            // Get language filter from language filter group
            const languageGroup = document.querySelector('.language-filter-group');
            if (languageGroup) {
                const activeBtn = languageGroup.querySelector('.btn.active');
                if (activeBtn) {
                    return activeBtn.getAttribute('data-language') || 'all';
                }
            }
            return 'all';
        }
        
        function setWatchFilter(filterValue, clickedBtn) {
            // Remove active class from all watched filter buttons (not language)
            const watchedGroup = document.querySelector('.filter-options .btn-group-toggle:not(.language-filter-group)');
            if (watchedGroup) {
                watchedGroup.querySelectorAll('.btn').forEach(btn => btn.classList.remove('active'));
            }
            
            // Add active class to clicked button
            clickedBtn.classList.add('active');
            
            // Apply filters if there's a search query
            applyFilters();
        }
        
        function setExploreLanguageFilter(languageValue, clickedBtn) {
            const languageGroup = document.getElementById('exploreLanguageFilterGroup');
            if (languageGroup) {
                languageGroup.querySelectorAll('.btn').forEach(btn => btn.classList.remove('active'));
            }
            clickedBtn.classList.add('active');
            // Apply filters when language changes
            applyExploreFilters();
        }
        
        async function loadLanguageFilters() {
            try {
                const response = await fetch('/api/language-counts');
                const data = await response.json();
                const counts = data.counts || {};
                
                const languageGroup = document.getElementById('exploreLanguageFilterGroup');
                if (!languageGroup) return;
                
                // Canonicalize codes and map to display names
                const codeToCanonical = {
                    'eng': 'en', 'spa': 'es', 'fra': 'fr', 'fre': 'fr', 'ger': 'de', 'deu': 'de',
                    'ita': 'it', 'por': 'pt', 'rus': 'ru', 'jpn': 'ja', 'jap': 'ja', 'kor': 'ko',
                    'zho': 'zh', 'chi': 'zh', 'hin': 'hi', 'swe': 'sv', 'dan': 'da', 'ara': 'ar',
                    'pol': 'pl', 'ice': 'is', 'cze': 'cs', 'fin': 'fi', 'unknown': 'unknown'
                };
                const languageNames = {
                    'all': 'All', 'en': 'English', 'es': 'Spanish', 'fr': 'French', 'de': 'German',
                    'it': 'Italian', 'pt': 'Portuguese', 'ru': 'Russian', 'ja': 'Japanese',
                    'ko': 'Korean', 'zh': 'Chinese', 'hi': 'Hindi', 'sv': 'Swedish', 'da': 'Danish',
                    'ar': 'Arabic', 'pl': 'Polish', 'is': 'Icelandic', 'cs': 'Czech', 'fi': 'Finnish',
                    'und': 'Unknown', 'unknown': 'Unknown', 'zxx': 'no language'
                };

                // Merge counts by canonical code
                const mergedCounts = {};
                for (const k of Object.keys(counts)) {
                    const raw = (k || '').toString().trim().toLowerCase();
                    const val = counts[k] || 0;
                    if (raw === 'all') {
                        mergedCounts['all'] = (mergedCounts['all'] || 0) + val;
                        continue;
                    }
                    const canonical = codeToCanonical[raw] || raw;
                    mergedCounts[canonical] = (mergedCounts[canonical] || 0) + val;
                }
                
                const sortedLanguages = Object.keys(mergedCounts).sort((a, b) => {
                    if (a === 'all') return -1;
                    if (b === 'all') return 1;
                    return mergedCounts[b] - mergedCounts[a];
                });
                
                let html = '<span style="margin-right: 8px; font-weight: 600; white-space: nowrap;">Audio language:</span>';
                for (const code of sortedLanguages) {
                    const count = mergedCounts[code];
                    const displayName = languageNames[code] || (code ? code : 'unknown');
                    const isActive = code === 'all' ? 'active' : '';
                    html += `<button type=\"button\" class=\"btn ${isActive}\" style=\"white-space:nowrap;margin:0;border-radius:0;\" data-language=\"${code}\" onclick=\"setExploreLanguageFilter('${code}', this)\">${displayName} (${count})</button>`;
                }
                
                languageGroup.innerHTML = html;
            } catch (error) {
                console.error('Error loading language filters:', error);
            }
        }
        
        function setExploreWatchFilter(filterValue, clickedBtn) {
            // Remove active class from all explore filter buttons
            const buttons = document.querySelectorAll('#pageExplore .btn-group-toggle .btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            // Add active class to clicked button
            clickedBtn.classList.add('active');
            
            // Apply explore filters
            applyExploreFilters();
        }
        const statusMessage = document.getElementById('statusMessage');
        let progressInterval = null;
		let progressPollInFlight = false;
		let progressAbortController = null;
        
        function showStatus(message, type = 'info') {
            statusMessage.innerHTML = `<div class="status-message ${type}">${escapeHtml(message)}</div>`;
            setTimeout(() => {
                statusMessage.innerHTML = '';
            }, 5000);
        }
        
        function formatTime(seconds) {
            if (!seconds) return 'Unknown';
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            if (h > 0) return `${h}h ${m}m`;
            return `${m}m ${s}s`;
        }

        function formatMinutes(seconds) {
            if (!seconds && seconds !== 0) return '';
            const minutes = Math.round(Number(seconds) / 60);
            if (!isFinite(minutes) || minutes <= 0) return '';
            return `${minutes} min`;
        }
        
        function formatDate(dateStr) {
            if (!dateStr) return '';
            const date = new Date(dateStr);
            return date.toLocaleDateString();
        }
        
        function formatSize(bytes) {
            if (!bytes) return '';
            const gb = bytes / (1024 * 1024 * 1024);
            if (gb >= 1) return `${gb.toFixed(2)} GB`;
            const mb = bytes / (1024 * 1024);
            return `${mb.toFixed(2)} MB`;
        }
        
        async function scanFolder() {
            const btn = document.getElementById('setupScanBtn') || document.getElementById('scanBtn');
            const progressContainer = document.getElementById('setupProgressContainer') || document.getElementById('progressContainer');
            const progressBar = document.getElementById('setupProgressBar') || document.getElementById('progressBar');
            const progressStatus = document.getElementById('setupProgressStatus') || document.getElementById('progressStatus');
            const progressCount = document.getElementById('setupProgressCount') || document.getElementById('progressCount');
            const progressFile = document.getElementById('setupProgressFile') || document.getElementById('progressFile');
            
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Scanning...';
            }
            if (progressContainer) {
                progressContainer.classList.add('active');
            }
            showStatus('Starting scan...', 'info');
            
            try {
                const response = await fetch('/api/index', { method: 'POST' });
                const data = await response.json();
                
                if (response.ok) {
                    // Start polling for progress
                    startProgressPolling(progressContainer, progressBar, progressStatus, progressCount, progressFile, btn);
                } else {
                    showStatus('Scan failed: ' + (data.detail || 'Unknown error'), 'error');
                    if (progressContainer) progressContainer.classList.remove('active');
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = 'Scan Movies Folder';
                    }
                }
            } catch (error) {
                showStatus('Scan failed: ' + error.message, 'error');
                if (progressContainer) progressContainer.classList.remove('active');
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Scan Movies Folder';
                }
            }
        }
        
        let lastLogCount = 0;
        
        function renderLogs(logWindow, logs) {
            if (!logWindow || !logs) return;
            
            // Only append new logs
            if (logs.length > lastLogCount) {
                const newLogs = logs.slice(lastLogCount);
                newLogs.forEach(log => {
                    const logEntry = document.createElement('div');
                    logEntry.className = `log-entry ${log.level}`;
                    
                    const timestamp = document.createElement('span');
                    timestamp.className = 'log-timestamp';
                    timestamp.textContent = log.timestamp;
                    
                    const level = document.createElement('span');
                    level.className = 'log-level';
                    level.textContent = `[${log.level.toUpperCase()}]`;
                    
                    const message = document.createElement('span');
                    message.textContent = log.message;
                    
                    logEntry.appendChild(timestamp);
                    logEntry.appendChild(level);
                    logEntry.appendChild(message);
                    logWindow.appendChild(logEntry);
                });
                
                // Auto-scroll to bottom
                logWindow.scrollTop = logWindow.scrollHeight;
                lastLogCount = logs.length;
            }
        }
        
        function startProgressPolling(progressContainer, progressBar, progressStatus, progressCount, progressFile, scanBtn) {
            if (progressInterval) {
                clearInterval(progressInterval);
				progressInterval = null;
			}
			// Abort any in-flight poll from a previous interval
			if (progressAbortController) {
				try { progressAbortController.abort(); } catch (e) {}
				progressAbortController = null;
				progressPollInFlight = false;
            }
            
            // Reset log counter
            lastLogCount = 0;
            
            // Find log window
            const logWindow = document.getElementById('setupScanLogWindow') || document.getElementById('scanLogWindow');
            if (logWindow) {
                logWindow.innerHTML = '';
                logWindow.style.display = 'block';
            }
            
            progressInterval = setInterval(async () => {
				// Prevent overlapping polls if the previous request hasn't finished
				if (progressPollInFlight) {
					return;
				}
                try {
					// Create a new controller per tick so we can cancel on stop
					progressAbortController = new AbortController();
					progressPollInFlight = true;
					const response = await fetch('/api/scan-progress', { signal: progressAbortController.signal });
                    const data = await response.json();
                    
                    if (data.is_scanning) {
                        const percent = Math.round(data.progress_percent);
                        if (progressBar) {
                            progressBar.style.width = percent + '%';
                            progressBar.textContent = percent + '%';
                        }
                        if (progressCount) progressCount.textContent = `${data.current} / ${data.total}`;
                        if (progressFile) progressFile.textContent = data.current_file ? `Scanning: ${data.current_file}` : '';
                        
                        if (progressStatus) {
                            if (data.status === 'counting') {
                                progressStatus.textContent = 'Counting files...';
                            } else if (data.status === 'scanning') {
                                progressStatus.textContent = 'Scanning movies...';
                            } else {
                                progressStatus.textContent = data.status;
                            }
                        }
                        
                        // Render logs
                        if (data.logs && logWindow) {
                            renderLogs(logWindow, data.logs);
                        }
                    } else {
                        // Scan complete
                        clearInterval(progressInterval);
                        progressInterval = null;
						// Abort any pending fetch
						if (progressAbortController) {
							try { progressAbortController.abort(); } catch (e) {}
							progressAbortController = null;
						}
						progressPollInFlight = false;
                        // Keep progress container visible to show scan logs
                        // Don't remove 'active' class so log window remains visible
                        if (scanBtn) {
                            scanBtn.disabled = false;
                            scanBtn.textContent = 'Scan Movies Folder';
                        }
                        
                        // Final log render
                        if (data.logs && logWindow) {
                            renderLogs(logWindow, data.logs);
                        }
                        
                        // Update progress status to show completion
                        if (progressStatus) {
                            if (data.status === 'complete') {
                                progressStatus.textContent = `Scan complete: ${data.current} movies indexed`;
                                if (progressBar) {
                                    progressBar.style.width = '100%';
                                    progressBar.textContent = '100%';
                                }
                                if (progressFile) progressFile.textContent = '';
                            } else if (data.status.startsWith('error')) {
                                progressStatus.textContent = 'Scan error: ' + data.status;
                            }
                        }
                        
                        if (data.status === 'complete') {
                            showStatus(`Scan complete: ${data.current} movies indexed`, 'success');
                            loadStats();
                            // Reload setup stats if on setup page
                            const route = getRoute();
                            if (route === '/setup') {
                                loadSetupPage();
                            }
                        } else if (data.status.startsWith('error')) {
                            showStatus('Scan error: ' + data.status, 'error');
                        }
                    }
				} catch (error) {
					// Ignore AbortError noise when we intentionally cancel
                    console.error('Progress polling error:', error);
				} finally {
					progressPollInFlight = false;
					// Do not reuse old controllers
					progressAbortController = null;
                }
            }, 500); // Poll every 500ms
        }
        
        // Debounced, abortable search (single fetch, no infinite scroll)
        async function doSearch(query) {
            if (query.length < 2) {
                autocomplete.style.display = 'none';
                if (!watchedViewActive) {
                    results.innerHTML = '';
                }
                return;
            }
            
            // Increment request counter for this search
            searchRequestCounter++;
            const requestId = searchRequestCounter;

            // Abort previous in-flight request
            try {
                if (searchAbortController) {
                    searchAbortController.abort();
                }
            } catch (e) { /* ignore */ }
            searchAbortController = new AbortController();
            
            try {
                const filterType = getWatchFilter();
                const url = `/api/search?q=${encodeURIComponent(query)}&filter_type=${filterType}&language=all`;
                const response = await fetch(url, { signal: searchAbortController.signal });
                const data = await response.json();
                
                // Only display results if this response is from the latest request or newer than what's displayed
                if (requestId > lastDisplayedRequestId) {
                    lastDisplayedRequestId = requestId;
                    currentResults = data.results || [];
                    displayAutocomplete(currentResults);
                    displayResults(currentResults);
                }
                // Otherwise, silently discard this stale response
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Search error:', error);
                }
            }
        }

        function scheduleSearch(query) {
            if (searchDebounceTimer) {
                clearTimeout(searchDebounceTimer);
            }
            searchDebounceTimer = setTimeout(() => {
                doSearch(query);
            }, 250);
        }
        
        function applyFilters() {
            if (searchInput.value.length > 0) {
                scheduleSearch(searchInput.value);
            }
        }
        
        function clearSearch() {
            searchInput.value = '';
            autocomplete.style.display = 'none';
            results.innerHTML = '';
            currentResults = [];
            searchRequestCounter = 0;
            lastDisplayedRequestId = -1;
            updateClearButtonVisibility();
            searchInput.focus();
        }
        
        function updateClearButtonVisibility() {
            const clearBtn = document.getElementById('clearSearchBtn');
            if (clearBtn) {
                clearBtn.style.display = searchInput.value.length > 0 ? 'inline-block' : 'none';
            }
        }
        
        function displayAutocomplete(items) {
            if (items.length === 0) {
                autocomplete.style.display = 'none';
                return;
            }
            
            autocomplete.innerHTML = items.map((item, index) => `
                <div class="autocomplete-item" data-index="${index}">
                    <span class="movie-name">
                        ${escapeHtml(item.name)}
                        ${item.watched ? '<span class="watched-badge">Watched</span>' : ''}
                    </span>
                    <span class="movie-meta">
                        ${item.length ? formatTime(item.length) : ''}
                        ${item.created ? ' • ' + formatDate(item.created) : ''}
                    </span>
                </div>
            `).join('');
            
            autocomplete.style.display = 'block';
            selectedIndex = -1;
        }

        // Pagination helpers removed for single-fetch mode
        
        async function loadSubtitles(videoPath) {
            if (currentSubtitles[videoPath]) {
                return currentSubtitles[videoPath];
            }
            
            try {
                const response = await fetch(`/api/subtitles?video_path=${encodeURIComponent(videoPath)}`);
                const data = await response.json();
                currentSubtitles[videoPath] = data.subtitles || [];
                return currentSubtitles[videoPath];
            } catch (error) {
                console.error('Subtitle error:', error);
                return [];
            }
        }
        
        function renderMediaGallery(images, screenshots, itemPath) {
            const allMedia = [];
            
            // Add folder images first
            if (images && images.length > 0) {
                images.forEach((img, idx) => {
                    allMedia.push({
                        path: img,
                        type: 'image',
                        label: idx === 0 ? 'Poster' : `Image ${idx + 1}`
                    });
                });
            }
            
            // Add screenshots
            if (screenshots && screenshots.length > 0) {
                screenshots.forEach((screenshot, idx) => {
                    allMedia.push({
                        path: screenshot,
                        type: 'screenshot',
                        label: `Screenshot ${idx + 1}`
                    });
                });
            }
            
            if (allMedia.length === 0) {
                return '';
            }
            
            // Show first image larger, rest as thumbnails
            const firstMedia = allMedia[0];
            const restMedia = allMedia.slice(1, 6); // Limit to 5 more
            
            let galleryHtml = '<div class="media-gallery">';
            
            // First image (larger)
            galleryHtml += `
                <div class="media-item large" onclick="showMediaOverlay('${escapeHtml(firstMedia.path)}')" style="position: relative;">
                    <button 
                        class="get-more-btn" 
                        title="Get more screenshots" 
                        onclick="event.stopPropagation(); getMoreScreenshots('${escapeJsString(itemPath)}');" 
                        style="position: absolute; top: 8px; right: 8px; font-size: 11px; padding: 4px 8px; opacity: 0.85;">
                        Get more
                    </button>
                    <img src="/api/image?image_path=${encodeURIComponent(firstMedia.path)}" 
                         alt="" 
                         loading="lazy"
                         onerror="this.style.display='none'">
                </div>
            `;
            
            // Rest as thumbnails
            restMedia.forEach(media => {
                galleryHtml += `
                    <div class="media-item" onclick="showMediaOverlay('${escapeHtml(media.path)}')">
                        <img src="/api/image?image_path=${encodeURIComponent(media.path)}" 
                             alt="" 
                             loading="lazy"
                             onerror="this.style.display='none'">
                    </div>
                `;
            });
            
            galleryHtml += '</div>';
            return galleryHtml;
        }
        
        function showMediaOverlay(imagePath) {
            const overlay = document.getElementById('mediaOverlay');
            const img = document.getElementById('mediaOverlayImage');
            img.src = `/api/image?image_path=${encodeURIComponent(imagePath)}`;
            overlay.classList.add('active');
        }
        
        function closeMediaOverlay() {
            const overlay = document.getElementById('mediaOverlay');
            overlay.classList.remove('active');
        }

        async function getMoreScreenshots(videoPath) {
            const btns = document.querySelectorAll('.get-more-btn');
            btns.forEach(b => { b.disabled = true; b.textContent = 'Queuing...'; });
            try {
                const resp = await fetch('/api/movie/screenshots/interval', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: videoPath, every_minutes: 5, async_mode: true })
                });
                const data = await resp.json();
                if (!resp.ok) {
                    showStatus('Failed to queue screenshots: ' + (data.detail || 'error'), 'error');
                } else {
                    showStatus('Queued ' + (data.queued || 0) + ' screenshots', 'success');
                    // Refresh details after a short delay, then start a short-lived polling
                    setTimeout(() => loadMovieDetails(videoPath), 1200);
                    // Poll updates for a short window so new screenshots appear as they are processed
                    let polls = 0;
                    const maxPolls = 15; // ~30 seconds
                    const pollIntervalMs = 2000;
                    const iv = setInterval(() => {
                        // If details page is no longer showing this movie, stop polling
                        const container = document.getElementById('movieDetailsContainer');
                        if (!container || !container.innerHTML || !container.innerHTML.includes(escapeHtml(videoPath))) {
                            clearInterval(iv);
                            return;
                        }
                        loadMovieDetails(videoPath);
                        polls += 1;
                        if (polls >= maxPolls) {
                            clearInterval(iv);
                        }
                    }, pollIntervalMs);
                }
            } catch (e) {
                showStatus('Failed to queue screenshots: ' + e.message, 'error');
            } finally {
                btns.forEach(b => { b.disabled = false; b.textContent = 'Get more'; });
            }
        }
        
        async function displayResults(items) {
            // Backward-compatible full replace render
            if (items.length === 0) {
                results.innerHTML = '<div class="empty-state">No results found</div>';
                return;
            }
            results.innerHTML = '<div class="movie-grid">' + items.map(item => createMovieCard(item)).join('') + '</div>';
        }

        // Append results helper removed in single-fetch mode
        
        async function updateSubtitle(videoPath, subtitlePath) {
            // Store subtitle selection for this video
            if (!currentSubtitles[videoPath]) {
                currentSubtitles[videoPath] = [];
            }
        }
        
        async function launchMovie(path) {
            try {
                const subtitleSelect = document.getElementById(`subtitle-${escapeHtml(path)}`);
                const subtitlePath = subtitleSelect ? subtitleSelect.value : null;
                const closeExistingVlc = document.getElementById('setupCloseExistingVlc').checked;
                
                const response = await fetch('/api/launch', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        path: path, 
                        subtitle_path: subtitlePath || null,
                        close_existing_vlc: closeExistingVlc
                    })
                });
                
                let data;
                try {
                    data = await response.json();
                } catch (e) {
                    throw new Error('Invalid response from server');
                }
                
                if (!response.ok) {
                    const errorMsg = data.detail || data.message || 'Launch failed';
                    showStatus('Launch failed: ' + errorMsg, 'error');
                    return;
                }
                
                if (data.status === 'launched') {
                    showStatus('Movie launched successfully', 'success');
                    // Refresh currently playing display after a successful launch
                    updateCurrentlyPlaying();
                } else {
                    showStatus('Launch failed: ' + (data.detail || 'Unknown error'), 'error');
                }
            } catch (error) {
                const errorMsg = 'Failed to launch movie: ' + error.message;
                showStatus(errorMsg, 'error');
            }
        }
        
        function generateExternalLinks(movieName) {
            // Clean up movie name - remove common patterns like year, quality, etc.
            let cleanName = movieName
                .replace(/\s*\(\d{4}\)\s*$/, '') // Remove year in parentheses at end
                .replace(/\s*\d{4}\s*$/, '') // Remove year at end
                .replace(/\s*-\s*\d{4}\s*$/, '') // Remove dash year at end
                .replace(/\s*\[.*?\]\s*/g, '') // Remove brackets content
                .replace(/\s*\(.*?\)\s*/g, '') // Remove parentheses content
                .replace(/\s*1080p|\s*720p|\s*480p|\s*4K|\s*BluRay|\s*DVDRip|\s*WEBRip|\s*x264|\s*x265/gi, '') // Remove quality tags
                .replace(/\s*S\d{2}E\d{2}/gi, '') // Remove episode numbers
                .replace(/\s*Season\s*\d+/gi, '') // Remove season numbers
                .trim();
            
            // URL encode the cleaned name
            const encodedName = encodeURIComponent(cleanName);
            // Create Letterboxd slug: lowercase, spaces to hyphens, remove special chars
            const letterboxdSlug = cleanName
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, '-')  // Replace non-alphanumeric with hyphens
                .replace(/^-+|-+$/g, '');     // Remove leading/trailing hyphens
            
            return {
                letterboxd: `https://letterboxd.com/film/${letterboxdSlug}/`,
                wikipedia: `https://en.wikipedia.org/wiki/Special:Search/${encodedName}`,
                imdb: `https://www.imdb.com/find?q=${encodedName}`,
                tmdb: `https://www.themoviedb.org/search?query=${encodedName}`,
                douban: `https://movie.douban.com/subject_search?search_text=${encodedName}`,
                google: `https://www.google.com/search?q=${encodedName}+movie`
            };
        }
        
        async function openFolder(path) {
            try {
                const response = await fetch(`/api/open-folder?path=${encodeURIComponent(path)}`, {
                    method: 'POST'
                });
                const data = await response.json();
                if (response.ok) {
                    showStatus('Folder opened', 'success');
                } else {
                    showStatus('Failed to open folder: ' + (data.detail || 'Unknown error'), 'error');
                }
            } catch (error) {
                showStatus('Failed to open folder: ' + error.message, 'error');
            }
        }
        
        async function toggleWatched(path, currentWatchStatus = null) {
            try {
                // If currentWatchStatus is null, determine from current results or fetch
                if (currentWatchStatus === null) {
                    // Try to find in current results first
                    const currentItem = currentResults.find(r => r.path === path);
                    if (currentItem) {
                        // Prefer watch_status if available, fallback to watched boolean
                        currentWatchStatus = currentItem.watch_status !== undefined ? currentItem.watch_status : (currentItem.watched ? true : null);
                    } else {
                        // Fallback: fetch movie details
                        try {
                            const movieResponse = await fetch(`/api/movie?path=${encodeURIComponent(path)}`);
                            if (movieResponse.ok) {
                                const movieData = await movieResponse.json();
                                currentWatchStatus = movieData.watch_status !== undefined ? movieData.watch_status : (movieData.watched ? true : null);
                            } else {
                                currentWatchStatus = null; // Default to unset
                            }
                        } catch (e) {
                            currentWatchStatus = null; // Default to unset
                        }
                    }
                }
                
                // Cycle through three states: None → True → False → None
                let newWatchStatus;
                if (currentWatchStatus === null || currentWatchStatus === undefined) {
                    newWatchStatus = true;  // unset → watched
                } else if (currentWatchStatus === true) {
                    newWatchStatus = false;  // watched → unwatched
                } else {
                    newWatchStatus = null;  // unwatched → unset
                }
                
                const response = await fetch('/api/watched', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({path: path, watch_status: newWatchStatus})
                });
                
                if (response.ok) {
                    // Refresh current view
                    if (watchedViewActive) {
                        loadWatchedMovies();
                    } else if (exploreViewActive) {
                        loadExploreMovies();
                    } else if (searchInput.value.length > 0) {
                        search(searchInput.value);
                    }
                    loadStats();
                }
            } catch (error) {
                showStatus('Failed to update watched status: ' + error.message, 'error');
            }
        }
        
        // Star rating functions are now in star-rating.js
        
        async function setRating(path, rating) {
            // Setting a rating automatically marks as watched
            console.log('setRating called:', {path, rating, ratingType: typeof rating});
            try {
                const requestBody = {path: path, watch_status: true, rating: rating};
                console.log('Sending rating request:', requestBody);
                const response = await fetch('/api/watched', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(requestBody)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Rating saved successfully:', result);
                    if (watchedViewActive) {
                        loadWatchedMovies();
                    } else if (exploreViewActive) {
                        loadExploreMovies();
                    } else if (searchInput.value.length > 0) {
                        search(searchInput.value);
                    }
                    loadStats();
                } else {
                    const errorText = await response.text();
                    console.error('Failed to save rating:', response.status, errorText);
                    showStatus('Failed to update rating: ' + errorText, 'error');
                }
            } catch (error) {
                console.error('Error in setRating:', error);
                showStatus('Failed to update rating: ' + error.message, 'error');
            }
        }
        
        async function loadWatchedMovies() {
            try {
                const response = await fetch('/api/watched');
                const data = await response.json();
                const watched = data.watched || [];
                
                if (watched.length === 0) {
                    watchedList.innerHTML = '<div class="empty-state">No watched movies yet</div>';
                    return;
                }
                
                watchedList.innerHTML = '<div class="movie-grid">' + watched.map(item => createMovieCard(item)).join('') + '</div>';
            } catch (error) {
                console.error('Watched movies error:', error);
                watchedList.innerHTML = '<div class="empty-state">Error loading watched movies</div>';
            }
        }
        
        function toggleWatchedView() {
            if (exploreViewActive) {
                toggleExploreView();
            }
            
            watchedViewActive = !watchedViewActive;
            
            if (watchedViewActive) {
                watchedSection.classList.add('active');
                viewWatchedBtn.textContent = 'Hide Watched';
                results.style.display = 'none';
                loadWatchedMovies();
            } else {
                watchedSection.classList.remove('active');
                viewWatchedBtn.textContent = 'View Watched';
                results.style.display = 'block';
            }
        }
        
        function toggleExploreView() {
            navigateTo('/explore');
        }
        
        // Navigate to explore view with year filter and optionally scroll to specific movie
        async function navigateToExploreWithYear(year, movieId) {
            if (!year) return;
            
            // Navigate to explore view
            navigateTo('/explore');
            
            // Wait for explore page to be active
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Clear all zone filters first
            clearAllZoneFilters();
            
            // Set the year filter
            const { filterType } = getCurrentExploreFilters();
            await fetchExploreMovies(1, filterType, null, null, year);
            
            // Year chip will be rendered by renderYearFilter
            
            // Wait for movies to render, then scroll to the specific movie if movieId provided
            if (movieId) {
                setTimeout(() => {
                    const movieCard = document.querySelector(`.movie-card[data-movie-id="${movieId}"]`);
                    if (movieCard) {
                        movieCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // Add a highlight effect
                        movieCard.style.transition = 'box-shadow 0.3s';
                        movieCard.style.boxShadow = '0 0 20px rgba(74, 158, 255, 0.8)';
                        setTimeout(() => {
                            movieCard.style.boxShadow = '';
                        }, 2000);
                    }
                }, 500);
            }
        }
        
        // Standard AJAX pattern: read UI state, build request, fetch, update UI
        function getCurrentExploreFilters() {
            // Read filter type from button group
            const activeBtn = document.querySelector('#pageExplore .btn-group-toggle .btn.active');
            const filterType = activeBtn ? activeBtn.dataset.filter || 'all' : 'all';
            
            // Read letter from active letter button
            const activeLetterBtn = document.querySelector('.letter-btn.active[data-letter]');
            const letter = activeLetterBtn ? activeLetterBtn.dataset.letter : null;
            
            // Read decade from active decade button
            const activeDecadeBtn = document.querySelector('.decade-btn.active[data-decade]');
            const decade = activeDecadeBtn ? parseInt(activeDecadeBtn.dataset.decade) : null;
            
            // Read year from active year chip
            const yearChip = document.querySelector('.year-chip[data-year]');
            const year = yearChip ? parseInt(yearChip.dataset.year) : null;
            
            // Read language from explore language filter group
            const langBtn = document.querySelector('#exploreLanguageFilterGroup .btn.active[data-language]');
            const language = langBtn ? (langBtn.getAttribute('data-language') || 'all') : 'all';
            
            return { filterType, letter, decade, year, language };
        }
        
        async function fetchExploreMovies(page, filterType, letter, decade, year) {
            try {
                const params = new URLSearchParams({
                    page: page.toString(),
                    per_page: EXPLORE_PER_PAGE.toString(),
                    filter_type: filterType
                });
                
                if (letter) {
                    params.append('letter', letter);
                }
                
                if (decade !== null && decade !== undefined) {
                    params.append('decade', decade.toString());
                }
                
                if (year !== null && year !== undefined) {
                    params.append('year', year.toString());
                }
                
                // Always include language from current explore state (even 'all' for clarity)
                const { language } = getCurrentExploreFilters();
                params.append('language', language || 'all');
                
                const url = `/api/explore?${params}`;
                console.log('fetchExploreMovies called with:', { page, filterType, letter, decade, year, language });
                console.log('Request URL:', url);
                const response = await fetch(url);
                
                if (!response.ok) {
                    let errorMessage = 'Unknown error';
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.detail || errorMessage;
                    } catch (e) {
                        errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    }
                    showStatus('Failed to load movies: ' + errorMessage, 'error');
                    return;
                }
                
                const data = await response.json();
                
                // Update current page
                currentExplorePage = page;
                
                // Render navigation with current filter state
                renderLetterNav(data.letter_counts || {}, letter);
                renderDecadeNav(data.decade_counts || {}, decade);
                renderYearFilter(data.year_counts || {}, year);
                
                // Render movie grid
                renderMovieGrid(data.movies || []);
                
                // Render pagination
                renderPagination(data.pagination, filterType, letter, decade, year);
                
            } catch (error) {
                showStatus('Error loading movies: ' + error.message, 'error');
                console.error('Explore error:', error);
            }
        }
        
        // Filter change handlers - read UI state and make request
        function applyExploreFilters() {
            const { filterType, letter, decade, year } = getCurrentExploreFilters();
            // Do not clear other filters; combine filters and reset to page 1
            fetchExploreMovies(1, filterType, letter, decade, year);
        }
        
        function jumpToLetter(letter) {
            const { filterType } = getCurrentExploreFilters();
            // Clear decade and year when selecting letter
            clearDecadeFilter();
            clearYearFilter();
            fetchExploreMovies(1, filterType, letter, null, null);
        }
        
        function clearLetterFilter() {
            document.querySelectorAll('.letter-btn').forEach(btn => btn.classList.remove('active'));
        }
        
        function jumpToDecade(decade) {
            const { filterType } = getCurrentExploreFilters();
            // Clear letter and year when selecting decade
            clearLetterFilter();
            clearYearFilter();
            fetchExploreMovies(1, filterType, null, decade, null);
        }
        
        function clearDecadeFilter() {
            document.querySelectorAll('.decade-btn').forEach(btn => btn.classList.remove('active'));
        }
        
        function jumpToYear(year) {
            const { filterType } = getCurrentExploreFilters();
            // Clear letter and decade when selecting year
            clearLetterFilter();
            clearDecadeFilter();
            fetchExploreMovies(1, filterType, null, null, year);
        }
        
        function navigateToAdjacentYear(year, direction) {
            if (!year || year === null) return;
            jumpToYear(year);
        }
        
        function clearYearFilter() {
            const yearChipContainer = document.getElementById('yearChipContainer');
            const yearInput = document.getElementById('yearInput');
            if (yearChipContainer) {
                yearChipContainer.innerHTML = '';
            }
            if (yearInput) {
                yearInput.value = '';
            }
            const { filterType, letter, decade } = getCurrentExploreFilters();
            fetchExploreMovies(1, filterType, letter, decade, null);
        }
        
        function clearAllZoneFilters() {
            clearLetterFilter();
            clearDecadeFilter();
            clearYearFilter();
        }
        
        function goToExplorePage(page) {
            const { filterType, letter, decade, year } = getCurrentExploreFilters();
            fetchExploreMovies(page, filterType, letter, decade, year);
        }
        
        // Initial load - reads UI state
        function loadExploreMovies() {
            const { filterType, letter, decade, year } = getCurrentExploreFilters();
            fetchExploreMovies(currentExplorePage || 1, filterType, letter, decade, year);
        }
        
        function renderLetterNav(letterCounts, activeLetter) {
            const letterNav = document.getElementById('letterNav');
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
            
            let html = '';
            
            // Add "All" button
            const allCount = Object.values(letterCounts).reduce((sum, count) => sum + count, 0);
            html += `<button class="letter-btn ${!activeLetter ? 'active' : ''}" data-action="clear">All (${allCount})</button>`;
            
            // Add letter buttons
            for (const letter of letters) {
                const count = letterCounts[letter] || 0;
                const isActive = activeLetter === letter;
                html += `<button class="letter-btn ${isActive ? 'active' : ''}" ${count === 0 ? 'disabled' : ''} data-letter="${letter}">${letter} (${count})</button>`;
            }
            
            // Add "#" for non-alphabetic
            const hashCount = letterCounts['#'] || 0;
            const isHashActive = activeLetter === '#';
            html += `<button class="letter-btn ${isHashActive ? 'active' : ''}" ${hashCount === 0 ? 'disabled' : ''} data-letter="#"># (${hashCount})</button>`;
            
            letterNav.innerHTML = html;
            
            // Attach event listeners to all letter buttons
            letterNav.querySelectorAll('.letter-btn').forEach(btn => {
                if (btn.disabled) {
                    return;
                }
                
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (btn.dataset.action === 'clear') {
                        clearLetterFilter();
                        clearDecadeFilter();
                        clearYearFilter();
                        const { filterType } = getCurrentExploreFilters();
                        fetchExploreMovies(1, filterType, null, null, null);
                    } else if (btn.dataset.letter) {
                        jumpToLetter(btn.dataset.letter);
                    }
                });
            });
        }
        
        function renderDecadeNav(decadeCounts, activeDecade) {
            const decadeNav = document.getElementById('decadeNav');
            if (!decadeNav) return;
            
            // Get all decades that have movies, sorted
            const decades = Object.keys(decadeCounts).map(d => parseInt(d)).filter(d => d >= 1900 && d <= 2030).sort((a, b) => b - a);
            
            let html = '';
            
            // Add "All" button
            const allCount = Object.values(decadeCounts).reduce((sum, count) => sum + count, 0);
            html += `<button class="decade-btn ${!activeDecade ? 'active' : ''}" data-action="clear">All (${allCount})</button>`;
            
            // Add decade buttons
            for (const decade of decades) {
                const count = decadeCounts[decade] || 0;
                const isActive = activeDecade === decade;
                const decadeLabel = `${decade}s`;
                html += `<button class="decade-btn ${isActive ? 'active' : ''}" ${count === 0 ? 'disabled' : ''} data-decade="${decade}">${decadeLabel} (${count})</button>`;
            }
            
            decadeNav.innerHTML = html;
            
            // Attach event listeners
            decadeNav.querySelectorAll('.decade-btn').forEach(btn => {
                if (btn.disabled) {
                    return;
                }
                
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (btn.dataset.action === 'clear') {
                        clearDecadeFilter();
                        clearLetterFilter();
                        clearYearFilter();
                        const { filterType } = getCurrentExploreFilters();
                        fetchExploreMovies(1, filterType, null, null, null);
                    } else if (btn.dataset.decade) {
                        jumpToDecade(parseInt(btn.dataset.decade));
                    }
                });
            });
        }
        
        // Store available years for autocomplete
        let availableYears = []
        // Store year counts for autocomplete
        let currentYearCounts = {};
        
        function renderYearFilter(yearCounts, activeYear) {
            const yearInput = document.getElementById('yearInput');
            const yearChipContainer = document.getElementById('yearChipContainer');
            if (!yearInput || !yearChipContainer) return;
            
            // Get all years that have movies, sorted descending
            availableYears = Object.keys(yearCounts).map(y => parseInt(y)).filter(y => y >= 1900 && y <= 2035).sort((a, b) => b - a);
            
            // Render chip if year is active
            if (activeYear) {
                const count = yearCounts[activeYear] || 0;
                
                // Find adjacent years in available years (sorted descending)
                const currentIndex = availableYears.indexOf(activeYear);
                const laterYear = currentIndex > 0 ? availableYears[currentIndex - 1] : null; // Later year (left button, +1, smaller index = larger year)
                const earlierYear = currentIndex < availableYears.length - 1 ? availableYears[currentIndex + 1] : null; // Earlier year (right button, -1, larger index = smaller year)
                
                yearChipContainer.innerHTML = `
                    <button class="year-nav-btn" ${!laterYear ? 'disabled' : ''} onclick="navigateToAdjacentYear(${laterYear || 'null'}, 'later')" title="Later year (${laterYear || 'N/A'})">◀</button>
                    <div class="year-chip" data-year="${activeYear}">
                        <span>${activeYear}</span>
                        <span class="year-chip-close" onclick="clearYearFilter()" title="Clear year filter">×</span>
                    </div>
                    <button class="year-nav-btn" ${!earlierYear ? 'disabled' : ''} onclick="navigateToAdjacentYear(${earlierYear || 'null'}, 'earlier')" title="Earlier year (${earlierYear || 'N/A'})">▶</button>
                `;
                yearInput.value = '';
            } else {
                yearChipContainer.innerHTML = '';
            }
            
            // Setup autocomplete if not already set up, or update year counts
            if (!yearInput.dataset.autocompleteSetup) {
                setupYearAutocomplete(yearInput, yearCounts);
                yearInput.dataset.autocompleteSetup = 'true';
            } else {
                // Update year counts for existing autocomplete
                currentYearCounts = yearCounts;
            }
        }
        
        function setupYearAutocomplete(input, yearCounts) {
            const autocomplete = document.getElementById('yearAutocomplete');
            let selectedIndex = -1;
            
            // Update stored year counts
            currentYearCounts = yearCounts;
            
            input.addEventListener('input', (e) => {
                const query = e.target.value.trim();
                
                if (!query) {
                    autocomplete.style.display = 'none';
                    return;
                }
                
                // Filter years that match the query
                const queryNum = parseInt(query);
                const matches = availableYears.filter(year => {
                    if (!isNaN(queryNum)) {
                        return year.toString().startsWith(query);
                    }
                    return false;
                }).slice(0, 10); // Limit to 10 results
                
                if (matches.length === 0) {
                    autocomplete.style.display = 'none';
                    return;
                }
                
                // Render autocomplete items
                autocomplete.innerHTML = matches.map((year, index) => {
                    const count = currentYearCounts[year] || 0;
                    return `<div class="year-autocomplete-item" data-year="${year}" data-index="${index}">${year} (${count})</div>`;
                }).join('');
                
                autocomplete.style.display = 'block';
                selectedIndex = -1;
            });
            
            input.addEventListener('keydown', (e) => {
                const items = autocomplete.querySelectorAll('.year-autocomplete-item');
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                    updateAutocompleteSelection(items, selectedIndex);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    updateAutocompleteSelection(items, selectedIndex);
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (selectedIndex >= 0 && items[selectedIndex]) {
                        const year = parseInt(items[selectedIndex].dataset.year);
                        selectYear(year);
                    } else if (items.length === 1) {
                        const year = parseInt(items[0].dataset.year);
                        selectYear(year);
                    } else {
                        // Try to parse input as year
                        const year = parseInt(input.value.trim());
                        if (!isNaN(year) && availableYears.includes(year)) {
                            selectYear(year);
                        }
                    }
                } else if (e.key === 'Escape') {
                    autocomplete.style.display = 'none';
                    input.blur();
                }
            });
            
            // Click on autocomplete item
            autocomplete.addEventListener('click', (e) => {
                const item = e.target.closest('.year-autocomplete-item');
                if (item) {
                    const year = parseInt(item.dataset.year);
                    selectYear(year);
                }
            });
            
            // Close autocomplete when clicking outside
            document.addEventListener('click', (e) => {
                if (!input.contains(e.target) && !autocomplete.contains(e.target)) {
                    autocomplete.style.display = 'none';
                }
            });
        }
        
        function updateAutocompleteSelection(items, index) {
            items.forEach((item, i) => {
                if (i === index) {
                    item.classList.add('active');
                    item.scrollIntoView({ block: 'nearest' });
                } else {
                    item.classList.remove('active');
                }
            });
        }
        
        function selectYear(year) {
            const yearInput = document.getElementById('yearInput');
            const autocomplete = document.getElementById('yearAutocomplete');
            
            if (yearInput) {
                yearInput.value = '';
            }
            if (autocomplete) {
                autocomplete.style.display = 'none';
            }
            
            jumpToYear(year);
        }
        
        function renderMovieGrid(movies) {
            const movieGrid = document.getElementById('movieGrid');
            
            if (!movieGrid) {
                console.error('movieGrid element not found');
                return;
            }
            
            // Always clear the grid first
            movieGrid.innerHTML = '';
            
            if (!movies || movies.length === 0) {
                console.log('No movies to render, showing empty state');
                movieGrid.innerHTML = '<div class="empty-state">No movies found</div>';
                return;
            }
            
            
            movieGrid.innerHTML = movies.map(movie => createMovieCard(movie)).join('');
            
            
        }
        
        async function loadMovieDetails(path) {
            const container = document.getElementById('movieDetailsContainer');
            container.innerHTML = '<div class="loading">Loading movie details...</div>';
            
            try {
                const response = await fetch(`/api/movie?path=${encodeURIComponent(path)}`);
                const movie = await response.json();
                
                if (!response.ok) {
                    container.innerHTML = `<div class="empty-state">Error: ${movie.detail || 'Failed to load movie'}</div>`;
                    return;
                }
                
                const imageUrl = movie.image ? `/api/image?image_path=${encodeURIComponent(movie.image)}` : '';
                const externalLinks = generateExternalLinks(movie.name);
                const mediaGallery = renderMediaGallery(movie.images || [], movie.screenshots || [], movie.path);
                
                // Use watch_status if available, fallback to watched boolean for backward compatibility
                const watchStatus = movie.watch_status !== undefined ? movie.watch_status : (movie.watched ? true : null);
                const isWatched = watchStatus === true;
                
                // Load subtitles
                await loadSubtitles(movie.path);
                const subtitles = currentSubtitles[movie.path] || [];
                let subtitleSelect = '';
                if (subtitles.length > 0) {
                    subtitleSelect = `
                        <select class="subtitle-select" id="subtitle-${escapeHtml(movie.path)}" onchange="updateSubtitle('${escapeJsString(movie.path)}', this.value)">
                            <option value="">No subtitle</option>
                            ${subtitles.map(sub => `<option value="${escapeJsString(sub.path)}">${escapeHtml(sub.name)}</option>`).join('')}
                        </select>
                    `;
                }
                
                container.innerHTML = `
                    <div class="movie-details-header">
                        <div class="movie-details-poster">
                            ${imageUrl ? `<img src="${imageUrl}" alt="${escapeHtml(movie.name)}">` : 'No Image'}
                        </div>
                        <div class="movie-details-info">
                            <h1 class="movie-details-title">${escapeHtml(movie.name)}</h1>
                            <div class="movie-details-meta">
                                ${movie.year ? `<span class="year-link" onclick="navigateToExploreWithYear(${movie.year}, ${movie.id || 'null'});" title="Filter by ${movie.year}">${movie.year}</span>` : ''}
                                ${movie.length ? `<span>${formatMinutes(movie.length)}</span>` : ''}
                                ${movie.size ? `<span>${formatSize(movie.size)}</span>` : ''}
                                ${movie.watched_date ? `<span>Watched: ${formatDate(movie.watched_date)}</span>` : ''}
                            </div>
                            <div class="movie-details-actions">
                                ${renderStarRating(movie.path, isWatched, movie.rating)}
                                <button class="watched-btn ${isWatched ? 'watched' : ''}" onclick="toggleWatched('${escapeJsString(movie.path)}', ${watchStatus === null ? 'null' : watchStatus})">
                                    ${isWatched ? '✓ Watched' : watchStatus === false ? '✗ Unwatched' : 'Mark Watched'}
                                </button>
                                ${subtitleSelect}
                                <button class="launch-btn" onclick="launchMovie('${escapeJsString(movie.path)}')">Launch</button>
                            </div>
                            <div class="external-links" style="margin-top: 20px;">
                                <a href="${externalLinks.letterboxd}" target="_blank" class="external-link">Letterboxd</a>
                                <a href="${externalLinks.wikipedia}" target="_blank" class="external-link">Wikipedia</a>
                                <a href="${externalLinks.imdb}" target="_blank" class="external-link">IMDb</a>
                                <a href="${externalLinks.tmdb}" target="_blank" class="external-link">TMDB</a>
                                <a href="${externalLinks.douban}" target="_blank" class="external-link">Douban</a>
                                <a href="${externalLinks.google}" target="_blank" class="external-link">Google</a>
                                <a href="#" onclick="event.preventDefault(); openFolder('${escapeJsString(movie.path)}'); return false;" class="external-link">Open Folder</a>
                            </div>
                            <div style="margin-top: 20px; color: #999; font-size: 12px;">
                                <div>Path: ${escapeHtml(movie.path)}</div>
                                ${movie.created ? `<div>Created: ${formatDate(movie.created)}</div>` : ''}
                            </div>
                        </div>
                    </div>
                    ${mediaGallery}
                `;
            } catch (error) {
                container.innerHTML = `<div class="empty-state">Error loading movie: ${error.message}</div>`;
            }
        }

        async function loadMovieDetailsById(id) {
            const container = document.getElementById('movieDetailsContainer');
            container.innerHTML = '<div class="loading">Loading movie details...</div>';

            try {
                const response = await fetch(`/api/movie/${encodeURIComponent(id)}`);
                const movie = await response.json();

                if (!response.ok) {
                    container.innerHTML = `<div class="empty-state">Error: ${movie.detail || 'Failed to load movie'}</div>`;
                    return;
                }

                const imageUrl = movie.image ? `/api/image?image_path=${encodeURIComponent(movie.image)}` : '';
                const externalLinks = generateExternalLinks(movie.name);
                const mediaGallery = renderMediaGallery(movie.images || [], movie.screenshots || [], movie.path);

                // Use watch_status if available, fallback to watched boolean for backward compatibility
                const watchStatus = movie.watch_status !== undefined ? movie.watch_status : (movie.watched ? true : null);
                const isWatched = watchStatus === true;

                // Load subtitles
                await loadSubtitles(movie.path);
                const subtitles = currentSubtitles[movie.path] || [];
                let subtitleSelect = '';
                if (subtitles.length > 0) {
                    subtitleSelect = `
                        <select class="subtitle-select" id="subtitle-${escapeHtml(movie.path)}" onchange="updateSubtitle('${escapeJsString(movie.path)}', this.value)">
                            <option value="">No subtitle</option>
                            ${subtitles.map(sub => `<option value="${escapeJsString(sub.path)}">${escapeHtml(sub.name)}</option>`).join('')}
                        </select>
                    `;
                }

                container.innerHTML = `
                    <div class="movie-details-header">
                        <div class="movie-details-poster">
                            ${imageUrl ? `<img src="${imageUrl}" alt="${escapeHtml(movie.name)}">` : 'No Image'}
                        </div>
                        <div class="movie-details-info">
                            <h1 class="movie-details-title">${escapeHtml(movie.name)}</h1>
                            <div class="movie-details-meta">
                                ${movie.year ? `<span class="year-link" onclick="navigateToExploreWithYear(${movie.year}, ${movie.id || 'null'});" title="Filter by ${movie.year}">${movie.year}</span>` : ''}
                                ${movie.length ? `<span>${formatTime(movie.length)}</span>` : ''}
                                ${movie.size ? `<span>${formatSize(movie.size)}</span>` : ''}
                                ${movie.watched_date ? `<span>Watched: ${formatDate(movie.watched_date)}</span>` : ''}
                            </div>
                            <div class="movie-details-actions">
                                ${renderStarRating(movie.path, isWatched, movie.rating)}
                                <button class="watched-btn ${isWatched ? 'watched' : ''}" onclick="toggleWatched('${escapeJsString(movie.path)}', ${watchStatus === null ? 'null' : watchStatus})">
                                    ${isWatched ? '✓ Watched' : watchStatus === false ? '✗ Unwatched' : 'Mark Watched'}
                                </button>
                                ${subtitleSelect}
                                <button class="launch-btn" onclick="launchMovie('${escapeJsString(movie.path)}')">Launch</button>
                            </div>
                            <div class="external-links" style="margin-top: 20px;">
                                <a href="${externalLinks.letterboxd}" target="_blank" class="external-link">Letterboxd</a>
                                <a href="${externalLinks.wikipedia}" target="_blank" class="external-link">Wikipedia</a>
                                <a href="${externalLinks.imdb}" target="_blank" class="external-link">IMDb</a>
                                <a href="${externalLinks.tmdb}" target="_blank" class="external-link">TMDB</a>
                                <a href="${externalLinks.douban}" target="_blank" class="external-link">Douban</a>
                                <a href="${externalLinks.google}" target="_blank" class="external-link">Google</a>
                                <a href="#" onclick="event.preventDefault(); openFolder('${escapeJsString(movie.path)}'); return false;" class="external-link">Open Folder</a>
                            </div>
                            <div style="margin-top: 20px; color: #999; font-size: 12px;">
                                <div>Path: ${escapeHtml(movie.path)}</div>
                                ${movie.created ? `<div>Created: ${formatDate(movie.created)}</div>` : ''}
                            </div>
                        </div>
                    </div>
                    ${mediaGallery}
                `;
            } catch (error) {
                container.innerHTML = `<div class="empty-state">Error loading movie: ${error.message}</div>`;
            }
        }
        
        function renderPagination(pagination, filterType, letter, decade, year) {
            const paginationEl = document.getElementById('explorePagination');
            
            if (pagination.pages <= 1) {
                paginationEl.innerHTML = '';
                return;
            }
            
            let html = '';
            
            // Previous button
            const prevPage = pagination.page - 1;
            html += `<button class="pagination-btn" ${pagination.page === 1 ? 'disabled' : ''} onclick="goToExplorePage(${prevPage})">Previous</button>`;
            
            // Page numbers
            const maxPages = 10;
            let startPage = Math.max(1, pagination.page - Math.floor(maxPages / 2));
            let endPage = Math.min(pagination.pages, startPage + maxPages - 1);
            
            if (endPage - startPage < maxPages - 1) {
                startPage = Math.max(1, endPage - maxPages + 1);
            }
            
            if (startPage > 1) {
                html += `<button class="pagination-btn" onclick="goToExplorePage(1)">1</button>`;
                if (startPage > 2) {
                    html += `<span class="pagination-info">...</span>`;
                }
            }
            
            for (let i = startPage; i <= endPage; i++) {
                const isActive = i === pagination.page;
                html += `<button class="pagination-btn ${isActive ? 'active' : ''}" onclick="goToExplorePage(${i})">${i}</button>`;
            }
            
            if (endPage < pagination.pages) {
                if (endPage < pagination.pages - 1) {
                    html += `<span class="pagination-info">...</span>`;
                }
                html += `<button class="pagination-btn" onclick="goToExplorePage(${pagination.pages})">${pagination.pages}</button>`;
            }
            
            // Next button
            const nextPage = pagination.page + 1;
            html += `<button class="pagination-btn" ${pagination.page === pagination.pages ? 'disabled' : ''} onclick="goToExplorePage(${nextPage})">Next</button>`;
            
            // Page info
            html += `<span class="pagination-info">Page ${pagination.page} of ${pagination.pages} (${pagination.total} total)</span>`;
            
            paginationEl.innerHTML = html;
        }
        
        async function loadStats() {
            try {
                const response = await fetch('/api/stats');
                const data = await response.json();
                const pathCount = Array.isArray(data.indexed_paths) ? data.indexed_paths.length : 0;
                if (stats) {
                    stats.innerHTML = `
                        <div>${data.total_movies} movies indexed total</div>
                    `;
                }
                return data;
            } catch (error) {
                console.error('Stats error:', error);
                return null;
            }
        }
        
        async function loadCurrentFolder() {
            try {
                const response = await fetch('/api/config');
                const data = await response.json();
                const folderPath = data.movies_folder || data.default_folder || 'Not set';
                const currentFolderEl = document.getElementById('currentFolder');
                const setupCurrentFolderEl = document.getElementById('setupCurrentFolder');
                if (currentFolderEl) currentFolderEl.textContent = folderPath;
                if (setupCurrentFolderEl) setupCurrentFolderEl.textContent = folderPath;
            } catch (error) {
                console.error('Config error:', error);
                const currentFolderEl = document.getElementById('currentFolder');
                const setupCurrentFolderEl = document.getElementById('setupCurrentFolder');
                if (currentFolderEl) currentFolderEl.textContent = 'Error loading';
                if (setupCurrentFolderEl) setupCurrentFolderEl.textContent = 'Error loading';
            }
        }
        
        async function loadSetupPage() {
            await loadCurrentFolder();
            const statsData = await loadStats();
            const setupStatsEl = document.getElementById('setupStats');
            if (setupStatsEl && statsData) {
                const pathCount = Array.isArray(statsData.indexed_paths) ? statsData.indexed_paths.length : 0;
                setupStatsEl.innerHTML = `
                    <div style="color: #e0e0e0; margin-bottom: 10px;">
                        <div style="margin-bottom: 5px;"><strong>${statsData.total_movies}</strong> movies indexed total</div>
                    </div>
                `;
            }
        }
        
        function normalizePath(path) {
            // Normalize path separators for Windows
            // Convert forward slashes to backslashes, handle double backslashes
            if (!path) return path;
            
            // Replace forward slashes with backslashes
            path = path.replace(/\//g, '\\');
            
            // Normalize double backslashes (but preserve UNC paths like \\server\share)
            // Only normalize if it's not at the start (UNC path)
            if (path.startsWith('\\\\') && path.length > 2) {
                // UNC path - keep the first two backslashes, normalize the rest
                const rest = path.substring(2).replace(/\\\\+/g, '\\');
                path = '\\\\' + rest;
            } else {
                // Regular path - normalize all double+ backslashes
                path = path.replace(/\\\\+/g, '\\');
            }
            
            // Remove trailing backslash (unless it's a root like C:\)
            if (path.length > 3 && path.endsWith('\\') && path.match(/^[A-Za-z]:\\$/)) {
                // Keep it - it's a drive root
            } else if (path.endsWith('\\')) {
                path = path.slice(0, -1);
            }
            
            return path;
        }
        
        function showFolderDialog() {
            const dialog = document.getElementById('folderDialog');
            const input = document.getElementById('folderPathInput');
            
            // Load current path into input
            loadCurrentFolder().then(() => {
                const setupCurrentFolderEl = document.getElementById('setupCurrentFolder');
                const currentPath = setupCurrentFolderEl ? setupCurrentFolderEl.textContent : '';
                if (currentPath && currentPath !== 'Loading...' && currentPath !== 'Error loading' && currentPath !== 'Not set') {
                    input.value = currentPath;
                } else {
                    input.value = '';
                }
            });
            
            dialog.classList.add('active');
            // Focus the input after a short delay to ensure dialog is visible
            setTimeout(() => {
                input.focus();
                input.select();
            }, 100);
        }
        
        function hideFolderDialog() {
            const dialog = document.getElementById('folderDialog');
            dialog.classList.remove('active');
        }
        
        async function saveFolderPath() {
            const input = document.getElementById('folderPathInput');
            let folderPath = input.value.trim();
            
            if (!folderPath) {
                showStatus('Please enter a folder path', 'error');
                return;
            }
            
            // Normalize the path (handle /, \, \\)
            folderPath = normalizePath(folderPath);
            
            try {
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({movies_folder: folderPath})
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    showStatus('Movies folder updated successfully', 'success');
                    loadCurrentFolder();
                    loadStats();
                    hideFolderDialog();
                } else {
                    showStatus('Failed to update folder: ' + (data.detail || 'Unknown error'), 'error');
                }
            } catch (error) {
                showStatus('Failed to update folder: ' + error.message, 'error');
            }
        }
        
        // Allow Enter key to save in folder dialog, ESC to close media overlay
        document.addEventListener('keydown', (e) => {
            const dialog = document.getElementById('folderDialog');
            const overlay = document.getElementById('mediaOverlay');
            
            if (dialog.classList.contains('active')) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveFolderPath();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    hideFolderDialog();
                }
            } else if (overlay.classList.contains('active')) {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    closeMediaOverlay();
                }
            }
        });
        
        // Close dialog when clicking outside
        document.addEventListener('click', (e) => {
            const dialog = document.getElementById('folderDialog');
            if (dialog.classList.contains('active') && e.target === dialog) {
                hideFolderDialog();
            }
        });
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function escapeJsString(text) {
            // Escape for JavaScript string literals - backslashes and quotes
            return text
                .replace(/\\/g, '\\\\')  // Escape backslashes
                .replace(/'/g, "\\'")    // Escape single quotes
                .replace(/"/g, '\\"');    // Escape double quotes
        }
        
        searchInput.addEventListener('input', (e) => {
            const route = getRoute();
            updateClearButtonVisibility();
            if (route === '/home' || route === '/') {
                scheduleSearch(e.target.value);
            }
        });
        
        searchInput.addEventListener('keydown', (e) => {
            const route = getRoute();
            if (route !== '/home' && route !== '/') return;
            
            const items = autocomplete.querySelectorAll('.autocomplete-item');
            
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                updateSelection(items);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedIndex = Math.max(selectedIndex - 1, -1);
                updateSelection(items);
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedIndex >= 0 && items[selectedIndex]) {
                    const item = currentResults[selectedIndex];
                    // Navigate to movie details for selected item
                    autocomplete.style.display = 'none';
                    updateClearButtonVisibility();
                    const slug = (item.name || '').toString().toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
                    openMovieHash(item.id, encodeURIComponent(slug));
                } else if (currentResults.length > 0) {
                    // Display current results (already full)
                    displayResults(currentResults);
                    autocomplete.style.display = 'none';
                    updateClearButtonVisibility();
                }
            } else if (e.key === 'Escape') {
                autocomplete.style.display = 'none';
            }
        });
        
        function updateSelection(items) {
            items.forEach((item, index) => {
                if (index === selectedIndex) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
        }
        
        autocomplete.addEventListener('click', (e) => {
            const item = e.target.closest('.autocomplete-item');
            if (item) {
                const index = parseInt(item.dataset.index);
                const movie = currentResults[index];
                searchInput.value = movie.name;
                autocomplete.style.display = 'none';
                displayResults([movie]);
                updateClearButtonVisibility();
            }
        });
        
        // loadCurrentFolder is already defined above - removed duplicate
        
        function showFolderDialog() {
            const dialog = document.getElementById('folderDialog');
            const input = document.getElementById('folderPathInput');
            
            // Load current path into input
            loadCurrentFolder().then(() => {
                const setupCurrentFolderEl = document.getElementById('setupCurrentFolder');
                const currentPath = setupCurrentFolderEl ? setupCurrentFolderEl.textContent : '';
                if (currentPath && currentPath !== 'Loading...' && currentPath !== 'Error loading' && currentPath !== 'Not set') {
                    input.value = currentPath;
                } else {
                    input.value = '';
                }
            });
            
            dialog.classList.add('active');
        }
        
        function hideFolderDialog() {
            const dialog = document.getElementById('folderDialog');
            dialog.classList.remove('active');
        }
        
        async function saveFolderPath() {
            const input = document.getElementById('folderPathInput');
            let folderPath = input.value.trim();
            
            if (!folderPath) {
                showStatus('Please enter a folder path', 'error');
                return;
            }
            
            // Normalize the path (handle /, \, \\)
            folderPath = normalizePath(folderPath);
            
            try {
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({movies_folder: folderPath})
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    showStatus('Movies folder updated successfully', 'success');
                    loadCurrentFolder();
                    loadStats();
                    hideFolderDialog();
                } else {
                    showStatus('Failed to update folder: ' + (data.detail || 'Unknown error'), 'error');
                }
            } catch (error) {
                showStatus('Failed to update folder: ' + error.message, 'error');
            }
        }
        
        // Close dialog when clicking outside
        document.addEventListener('click', (e) => {
            const dialog = document.getElementById('folderDialog');
            if (dialog.classList.contains('active') && e.target === dialog) {
                hideFolderDialog();
            }
        });
        
        // Currently playing functionality
        let currentlyPlayingInterval = null;
        
        async function updateCurrentlyPlaying() {
            try {
                const response = await fetch('/api/currently-playing');
                const data = await response.json();
                const playingEl = document.getElementById('currentlyPlaying');
                
                if (!playingEl) return;
                
                if (data.playing && data.playing.length > 0) {
                    // Show first playing movie (or all if multiple)
                    const firstMovie = data.playing[0];
                    playingEl.className = 'currently-playing has-movie';
                    // Render prefix and name with desired styling
                    playingEl.innerHTML = '<span class="prefix">now playing</span><span class="name"></span>';
                    const nameEl = playingEl.querySelector('.name');
                    if (nameEl) {
                        nameEl.textContent = firstMovie.name;
                    }
                    // Use hash route only when id is available
                    if (firstMovie.id) {
                        const slug = (firstMovie.name || '').toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
                        playingEl.onclick = () => openMovieHash(firstMovie.id, encodeURIComponent(slug));
                    } else {
                        playingEl.onclick = null;
                    }
                } else {
                    playingEl.className = 'currently-playing';
                    playingEl.textContent = 'nothing playing';
                    playingEl.onclick = null;
                }
            } catch (error) {
                console.error('Error updating currently playing:', error);
            }
        }
        
        function startCurrentlyPlayingPolling() {
            // Single update on load; no continuous polling
            updateCurrentlyPlaying();
            if (currentlyPlayingInterval) {
                clearInterval(currentlyPlayingInterval);
                currentlyPlayingInterval = null;
            }
        }
        
        function stopCurrentlyPlayingPolling() {
            if (currentlyPlayingInterval) {
                clearInterval(currentlyPlayingInterval);
                currentlyPlayingInterval = null;
            }
        }
        
        // History functions
        async function loadHistory() {
            const historyList = document.getElementById('historyList');
            if (!historyList) return;
            
            historyList.innerHTML = '<div class="loading">Loading history...</div>';
            
            try {
                const response = await fetch('/api/launch-history');
                const data = await response.json();
                
                if (!response.ok) {
                    historyList.innerHTML = '<div class="empty-state">Error loading history: ' + (data.detail || 'Unknown error') + '</div>';
                    return;
                }
                
                const launches = data.launches || [];
                
                if (launches.length === 0) {
                    historyList.innerHTML = '<div class="empty-state">No launch history yet</div>';
                    return;
                }
                
                let html = '';
                for (const launch of launches) {
                    const movie = launch.movie;
                    const timestamp = launch.timestamp;
                    
                    // Format timestamp with day of week
                    let formattedTime = 'Unknown time';
                    if (timestamp) {
                        try {
                            const date = new Date(timestamp);
                            const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                            const dayOfWeek = daysOfWeek[date.getDay()];
                            formattedTime = `${dayOfWeek}, ${date.toLocaleString()}`;
                        } catch (e) {
                            formattedTime = timestamp;
                        }
                    }
                    
                // Render movie card with a small timestamp below
                html += `
                    <div class="history-item">
                        <div class="history-movie-card">
                            ${createMovieCard(movie)}
                        </div>
                        <div class="history-timestamp">${escapeHtml(formattedTime)}</div>
                    </div>
                `;
                }
                
                historyList.innerHTML = html;
            } catch (error) {
                historyList.innerHTML = '<div class="empty-state">Error loading history: ' + error.message + '</div>';
                console.error('History error:', error);
            }
        }
        
        async function recleanAllNames() {
            const status = document.getElementById('recleanStatus');
            if (!status) return;
            
            status.style.display = 'block';
            status.style.background = '#2a2a2a';
            status.style.color = '#aaa';
            status.textContent = 'Re-cleaning all movie names...';
            
            try {
                const response = await fetch('/api/admin/reclean-names', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'}
                });
                const data = await response.json();
                
                if (response.ok) {
                    status.style.background = '#2d5a2d';
                    status.style.color = '#aaffaa';
                    status.textContent = data.message || `Re-cleaned ${data.updated} of ${data.total} movie names`;
                } else {
                    status.style.background = '#5a2d2d';
                    status.style.color = '#ffaaaa';
                    status.textContent = `Error: ${data.detail || 'Failed to re-clean names'}`;
                }
            } catch (error) {
                status.style.background = '#5a2d2d';
                status.style.color = '#ffaaaa';
                status.textContent = `Error: ${error.message || 'Unknown error'}`;
            }
        }
        
        // Ensure function is globally accessible
        window.recleanAllNames = recleanAllNames;
        
        // Load stats and folder path on page load
        loadStats();
        loadLanguageFilters();
        loadCurrentFolder();
        updateCurrentlyPlaying();
    </script>
</body>
</html>
