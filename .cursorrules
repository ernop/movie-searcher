# Cursor Rules

- Do not use emojis in project files or responses.
- Avoid compliments or praise; keep the tone neutral.
- Verify claims before agreeing; no reflexive agreement.
- Never include real credentials (API keys, tokens, passwords); use placeholders instead.

# PRIME DIRECTIVE - NO FALLBACKS

When something fails, fix the root cause. Never add alternative logic that tries to work around the failure.

## What is a Fallback?

A fallback is code that silently tries alternative methods when the primary method fails, instead of surfacing and fixing the failure.

## Example 1: Library Loading

WRONG:
```python
try:
    import preferred_library
    parser = preferred_library.Parser()
except ImportError:
    import backup_library
    parser = backup_library.Parser()
```

RIGHT:
```python
import preferred_library
parser = preferred_library.Parser()
```
If import fails, fix the environment or dependencies. Don't mask it.

## Example 2: Data Extraction (This Project's Core Case)

WRONG:
```python
# In indexing
movie.year = extract_year(filename)  # Returns None if extraction fails

# Later in API endpoint
def get_movie_details(movie):
    year = movie.year or try_parse_year_again(movie.filename) or "Unknown"
    return {"title": movie.title, "year": year}
```

RIGHT:
```python
# In indexing
movie.year = extract_year(filename)  # Returns None if extraction fails

# In API endpoint
def get_movie_details(movie):
    return {"title": movie.title, "year": movie.year}
```
If year is missing, improve `extract_year()` and re-index. Don't re-parse in the API.

## Example 3: Configuration Detection

WRONG:
```python
def get_vlc_path():
    path = os.environ.get("VLC_PATH")
    if not path:
        path = find_in_program_files()
    if not path:
        path = find_in_registry()
    if not path:
        path = "/usr/bin/vlc"  # Linux fallback
    return path
```

RIGHT:
```python
def get_vlc_path():
    path = os.environ.get("VLC_PATH")
    if not path:
        raise ConfigError("VLC_PATH not set. Set it in environment or config file.")
    return path
```
If VLC path is wrong, fix the configuration. Don't guess.

## Example 4: External Tool Calls

WRONG:
```python
try:
    duration = extract_duration_ffmpeg(video_file)
except Exception:
    try:
        duration = extract_duration_mediainfo(video_file)
    except Exception:
        duration = estimate_from_filesize(video_file)
```

RIGHT:
```python
duration = extract_duration_ffmpeg(video_file)
```
If ffmpeg fails, fix ffmpeg installation or the extraction logic. Don't cascade through alternatives.

## Example 5: tryAscertainValue Pattern

WRONG:
```python
def tryAscertainValue(data):
    # Try method 1
    value = parse_from_field_a(data)
    if value:
        return value
    
    # Try method 2
    value = parse_from_field_b(data)
    if value:
        return value
    
    # Try method 3
    value = guess_from_context(data)
    if value:
        return value
    
    return "default"
```

RIGHT:
```python
def get_value(data):
    return parse_from_field_a(data)
```
If field_a doesn't have the value, fix the data source or the data model. Don't try alternate fields.

## Example 6: Retry Loops

WRONG:
```python
def connect_to_service():
    for i in range(10):
        try:
            return service.connect()
        except ConnectionError:
            time.sleep(1)
    raise ConnectionError("Failed after 10 retries")
```

RIGHT:
```python
def connect_to_service():
    return service.connect()
```
If connection fails, fix the service availability, network config, or credentials. Don't retry and hope.

## The Rule

1. Use the correct method
2. If it fails, the error should be visible
3. Fix the method or fix the environment
4. Never add a second/third method to "help" when the first fails

## Why No Fallbacks?

Fallbacks create multiple sources of truth, hide bugs, and make debugging harder. They seem helpful but cause:

1. Inconsistent behavior - different code paths produce different results
2. Hidden failures - errors are masked instead of fixed
3. Maintenance burden - multiple methods to maintain and keep in sync
4. False confidence - system appears to work but produces unreliable data

When you see missing data or failures, the fix is always to improve the single upstream source, never to add downstream alternatives.

# DATABASE SCHEMA RULES

- Every table MUST have an autoincrement integer ID as primary key (NOT NULL)
- Every table MUST have `created` and `updated` DateTime fields that auto-update

# GENERAL DEVELOPMENT RULES

- Don't make up random extensions to what the user has asked; it's good to suggest options but you need to confirm and not just add things which might not be good without asking.

# NAME CLEANING RULES

- Name cleaning must NEVER rename, move, modify, or delete files on disk
- Only filter entries from the database and/or modify how they are displayed to users
- Files on disk must remain untouched - all changes are database/display-only

# UI/UX RULES

- UI elements must NEVER move, scale, or transform on hover
- Only change colors, borders, opacity, or other visual properties that don't affect layout or position
- No transform: scale(), translate(), rotate(), or z-index changes on hover states
